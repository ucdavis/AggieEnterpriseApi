directive @key(fields: String!) on OBJECT | INTERFACE

directive @extends on OBJECT | INTERFACE

directive @external on OBJECT | FIELD_DEFINITION

directive @requires(fields: String!) on FIELD_DEFINITION

directive @provides(fields: String!) on FIELD_DEFINITION

# A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
scalar Date

# A time string at UTC, such as 10:15:30Z, compliant with the `full-time` format outlined in section 5.6 of the RFC 3339profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
scalar Time

# A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
scalar DateTime

# The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
scalar Timestamp

# A field whose value exists in the standard IANA Time Zone Database: https://www.iana.org/time-zones
scalar TimeZone

# A field whose value is a UTC Offset: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
scalar UtcOffset

#
#     A string representing a duration conforming to the ISO8601 standard,
#     such as: P1W1DT13H23M34S
#     P is the duration designator (for period) placed at the start of the duration representation.
#     Y is the year designator that follows the value for the number of years.
#     M is the month designator that follows the value for the number of months.
#     W is the week designator that follows the value for the number of weeks.
#     D is the day designator that follows the value for the number of days.
#     T is the time designator that precedes the time components of the representation.
#     H is the hour designator that follows the value for the number of hours.
#     M is the minute designator that follows the value for the number of minutes.
#     S is the second designator that follows the value for the number of seconds.
#
#     Note the time designator, T, that precedes the time value.
#
#     Matches moment.js, Luxon and DateFns implementations
#     ,/. is valid for decimal places and +/- is a valid prefix
#
scalar Duration

#
#     A string representing a duration conforming to the ISO8601 standard,
#     such as: P1W1DT13H23M34S
#     P is the duration designator (for period) placed at the start of the duration representation.
#     Y is the year designator that follows the value for the number of years.
#     M is the month designator that follows the value for the number of months.
#     W is the week designator that follows the value for the number of weeks.
#     D is the day designator that follows the value for the number of days.
#     T is the time designator that precedes the time components of the representation.
#     H is the hour designator that follows the value for the number of hours.
#     M is the minute designator that follows the value for the number of minutes.
#     S is the second designator that follows the value for the number of seconds.
#
#     Note the time designator, T, that precedes the time value.
#
#     Matches moment.js, Luxon and DateFns implementations
#     ,/. is valid for decimal places and +/- is a valid prefix
#
scalar ISO8601Duration

# A local date string (i.e., with no associated timezone) in `YYYY-MM-DD` format, e.g. `2020-01-01`.
scalar LocalDate

# A local time string (i.e., with no associated timezone) in 24-hr `HH:mm[:ss[.SSS]]` format, e.g. `14:25` or `14:25:06` or `14:25:06.123`.
scalar LocalTime

# A local time string (i.e., with no associated timezone) in 24-hr `HH:mm[:ss[.SSS]]` format, e.g. `14:25` or `14:25:06` or `14:25:06.123`.  This scalar is very similar to the `LocalTime`, with the only difference being that `LocalEndTime` also allows `24:00` as a valid value to indicate midnight of the following day.  This is useful when using the scalar to represent the exclusive upper bound of a time block.
scalar LocalEndTime

# A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
scalar EmailAddress

# Floats that will have a value less than 0.
scalar NegativeFloat

# Integers that will have a value less than 0.
scalar NegativeInt

# A string that cannot be passed as an empty value
scalar NonEmptyString

# Floats that will have a value of 0 or more.
scalar NonNegativeFloat

# Integers that will have a value of 0 or more.
scalar NonNegativeInt

# Floats that will have a value of 0 or less.
scalar NonPositiveFloat

# Integers that will have a value of 0 or less.
scalar NonPositiveInt

# A field whose value conforms to the standard E.164 format as specified in: https://en.wikipedia.org/wiki/E.164. Basically this is +17895551234.
scalar PhoneNumber

# Floats that will have a value greater than 0.
scalar PositiveFloat

# Integers that will have a value greater than 0.
scalar PositiveInt

# A field whose value conforms to the standard postal code formats for United States, United Kingdom, Germany, Canada, France, Italy, Australia, Netherlands, Spain, Denmark, Sweden, Belgium, India, Austria, Portugal, Switzerland or Luxembourg.
scalar PostalCode

# Floats that will have a value of 0 or more.
scalar UnsignedFloat

# Integers that will have a value of 0 or more.
scalar UnsignedInt

# A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
scalar URL

# The `BigInt` scalar type represents non-fractional signed whole numeric values.
scalar BigInt

# The `BigInt` scalar type represents non-fractional signed whole numeric values.
scalar Long

# The `Byte` scalar type represents byte value as a Buffer
scalar Byte

# A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier.
scalar UUID

# A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier.
scalar GUID

# A field whose value is a hexadecimal: https://en.wikipedia.org/wiki/Hexadecimal.
scalar Hexadecimal

# A field whose value is a hex color code: https://en.wikipedia.org/wiki/Web_colors.
scalar HexColorCode

# A field whose value is a CSS HSL color: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#hsl()_and_hsla().
scalar HSL

# A field whose value is a CSS HSLA color: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#hsl()_and_hsla().
scalar HSLA

# A field whose value is a IPv4 address: https://en.wikipedia.org/wiki/IPv4.
scalar IPv4

# A field whose value is a IPv6 address: https://en.wikipedia.org/wiki/IPv6.
scalar IPv6

# A field whose value is a ISBN-10 or ISBN-13 number: https://en.wikipedia.org/wiki/International_Standard_Book_Number.
scalar ISBN

# A field whose value is a JSON Web Token (JWT): https://jwt.io/introduction.
scalar JWT

# A field whose value is a valid decimal degrees latitude number (53.471): https://en.wikipedia.org/wiki/Latitude
scalar Latitude

# A field whose value is a valid decimal degrees longitude number (53.471): https://en.wikipedia.org/wiki/Longitude
scalar Longitude

# A field whose value is a IEEE 802 48-bit MAC address: https://en.wikipedia.org/wiki/MAC_address.
scalar MAC

# A field whose value is a valid TCP port within the range of 0 to 65535: https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_ports
scalar Port

# A field whose value is a CSS RGB color: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba().
scalar RGB

# A field whose value is a CSS RGBA color: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba().
scalar RGBA

# The `SafeInt` scalar type represents non-fractional signed whole numeric values that are considered safe as defined by the ECMAScript specification.
scalar SafeInt

# A currency string, such as $21.25
scalar USCurrency

# A field whose value is a Currency: https://en.wikipedia.org/wiki/ISO_4217.
scalar Currency

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

# The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSONObject

# A field whose value is an International Bank Account Number (IBAN): https://en.wikipedia.org/wiki/International_Bank_Account_Number.
scalar IBAN

# A field whose value conforms with the standard mongodb object ID as described here: https://docs.mongodb.com/manual/reference/method/ObjectId/#ObjectId. Example: 5e5677d71bdc2ae76344968c
scalar ObjectID

# Represents NULL values
scalar Void

# A field whose value conforms to the standard DID format as specified in did-core: https://www.w3.org/TR/did-core/.
scalar DID

# A country code as defined by ISO 3166-1 alpha-2
scalar CountryCode

# The locale in the format of a BCP 47 (RFC 5646) standard string
scalar Locale

# In the US, an ABA routing transit number (`ABA RTN`) is a nine-digit code to identify the financial institution.
scalar RoutingNumber

# Banking account number is a string of 5 to 17 alphanumeric values for representing an generic account number
scalar AccountNumber

# A field whose value conforms to the standard cuid format as specified in https://github.com/ericelliott/cuid#broken-down
scalar Cuid

# Represents an accounting period in the GL module of Oracle Financials.  Used for validation of submitted journal entry data.
type ApAccountingPeriod {
  # The unique name of a GL Accounting Period
  periodName: ErpAccountingPeriodName!
  periodYear: PositiveInt!
  periodNumber: PositiveInt!
  periodStatus: ErpPeriodStatus!
  adjustmentPeriod: Boolean!
  startDate: Date!
  endDate: Date!
  yearStartDate: Date!
  quarterStartDate: Date!
  quarterNumber: PositiveInt!
  effectivePeriodNumber: PositiveInt!
  lastUpdateDate: Timestamp!
  lastUpdateUserId: ErpUserId
}

# Data object used to run searches on ApAccountingPeriod
input ApAccountingPeriodFilterInput {
  searchCommon: SearchCommonInputs
  periodName: StringFilterInput
  periodYear: IntFilterInput
  periodNumber: IntFilterInput
  periodStatus: StringFilterInput
  startDate: DateFilterInput
  endDate: DateFilterInput
  adjustmentPeriod: BooleanFilterInput
  lastUpdateDate: DateFilterInput
}

# Wrapper object for search results for ApAccountingPeriod
type ApAccountingPeriodSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ApAccountingPeriod!]!
}

# Represents an accounting period in the GL module of Oracle Financials.  Used for validation of submitted journal entry data.
type ArAccountingPeriod {
  # The unique name of a GL Accounting Period
  periodName: ErpAccountingPeriodName!
  periodYear: PositiveInt!
  periodNumber: PositiveInt!
  periodStatus: ErpPeriodStatus!
  adjustmentPeriod: Boolean!
  startDate: LocalDate!
  endDate: LocalDate!
  yearStartDate: LocalDate!
  quarterStartDate: LocalDate!
  quarterNumber: PositiveInt!
  effectivePeriodNumber: PositiveInt!
  lastUpdateDate: Timestamp!
  lastUpdateUserId: ErpUserId
}

# Data object used to run searches on ArAccountingPeriod
input ArAccountingPeriodFilterInput {
  searchCommon: SearchCommonInputs
  periodName: StringFilterInput
  periodYear: IntFilterInput
  periodNumber: IntFilterInput
  periodStatus: StringFilterInput
  startDate: DateFilterInput
  endDate: DateFilterInput
  adjustmentPeriod: BooleanFilterInput
  lastUpdateDate: DateFilterInput
}

# Wrapper object for search results for ArAccountingPeriod
type ArAccountingPeriodSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ArAccountingPeriod!]!
}

type ArCustomerAccount {
  # Value that uniquely identifies the CustomerAccount by number
  accountNumber: NonEmptyTrimmedString50

  # Value that uniquely identifies the CustomerAccount by name
  accountName: NonEmptyTrimmedString100

  # Status Code of the Customer Account
  status: NonEmptyTrimmedString10

  # Date/Time last updated
  lastUpdateDate: Timestamp
}

# Data object used to run searches on Supplier
input ArCustomerAccountFilterInput {
  searchCommon: SearchCommonInputs
  accountNumber: StringFilterInput
  accountName: StringFilterInput
}

# Wrapper object for search results for ArCustomerAccount
type ArCustomerAccountSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ArCustomerAccount!]!
}

# Account class for this accounting distribution. Valid values are:
#
# * REV - Revenue
# * FREIGHT - Freight
# * TAX - Tax
# * REC - Receivables
# * CHARGES -  Late Charges
# * UNBILL - Unbilled Receivables
# * UNEARN -  Unearned Revenue
#
# When the line type is LINE, the value for this column should be REV, UNBILL, UNEARN, or REC."
enum ArDistributionAccountClass {
  # Revenue
  REV

  # Receivable
  REC
}

enum ArLineType {
  LINE
}

# Request object for submitting an AR Invoice to Oracle Financials.
input ArInvoiceRequestInput {
  # Request-level header information common to all action requests.
  header: ActionRequestHeaderInput!

  # Main operation data.
  payload: ArInvoiceInput!
}

input ArInvoiceInput {
  # Centrally assigned source name for your boundary application.
  batchSourceName: NonEmptyTrimmedString50!

  # Centrally assigned type name.
  transactionTypeName: String!

  # Identifier of the transaction.  Must be unique from the source system.
  transactionNumber: NonEmptyTrimmedString20!
  customerAccountNumber: NonEmptyTrimmedString240!
  customerSiteNumber: NonEmptyTrimmedString240!
  transactionDate: LocalDate!

  # Identifies the accounting date of the transaction. The accounting date determines the accounting period that the transaction is recorded in the general ledger.
  accountingDate: LocalDate
  memoLineName: NonEmptyTrimmedString50
  lines: [ArInvoiceLineInput!]!
}

input ArInvoiceLineInput {
  lineType: ArLineType!
  description: NonEmptyTrimmedString240!
  lineAmount: NonNegativeFloat!
  quantity: NonNegativeFloat
  unitOfMeasureName: String
  customerOrderedQuantity: NonNegativeFloat
  unitSellingPrice: NonNegativeFloat
  unitStandardPrice: NonNegativeFloat
  distributions: [ArInvoiceDistributionInput!]!
}

# A single line representing a GL Journal Entry or PPM Cost.  A line must have only one of the two types of expense location specified.
input ArInvoiceDistributionInput {
  distributionAccountClass: ArDistributionAccountClass
  amount: NonNegativeFloat
  percent: NonNegativeFloat

  # GL Segment fields.
  glSegments: GlSegmentInput

  # Delimited complete GL segment string.  All fields of the GL Accounting Key must be provided.
  glSegmentString: GlSegmentString
}

# Output type for ArInvoice creation and follow-up status updates.
#
# Contains the overall request status.  After a successful creation of the document, will also contain the Oracle Financials assigned ID.
type ArInvoiceRequestStatusOutput {
  # Status of the action request overall.
  requestStatus: ActionRequestStatus!

  # Validation errors and messages from payload processing
  validationResults: ValidationResponse
}

# Invoice status information used to check remaining balances.
type ArInvoiceSummary {
  transactionNumber: String!
  transactionDate: LocalDate!
  complete: Boolean!
  remainingDueAmount: Float
  originalInvoiceAmount: Float!
}

type ArMemoLine {
  # Value that uniquely identifies the MemoLine by ID
  id: NonEmptyTrimmedString20

  # Value that uniquely identifies the MemoLine by name
  name: NonEmptyTrimmedString50

  # Longer description
  description: NonEmptyTrimmedString80

  # Type of the MemoLine
  type: NonEmptyTrimmedString10

  # Date the MemoLine was created
  creationDate: DateTime

  # Date/Time last updated
  lastUpdateDate: DateTime
}

# Data object used to run searches on MemoLine
input ArMemoLineFilterInput {
  searchCommon: SearchCommonInputs
  id: StringFilterInput
  name: StringFilterInput
}

# Wrapper object for search results for ArMemoLine
type ArMemoLineSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ArMemoLine!]!
}

# TODO
type ArPaymentTerm {
  id: Long!
  name: NonEmptyTrimmedString15!
  description: NonEmptyTrimmedString240!

  # The date from when the value is available for use.
  startDate: LocalDate

  # The date till which the value is available for use.
  endDate: LocalDate

  # Indicates that the AR Payment Term is in active use.
  inUse: Boolean!

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: Timestamp

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId
}

# Data object used to run searches on ArPaymentTerm
input ArPaymentTermFilterInput {
  searchCommon: SearchCommonInputs
  name: StringFilterInput
  inUse: BooleanFilterInput
  lastUpdateDateTime: DateFilterInput
}

# TODO
type ArPaymentTermSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ArPaymentTerm!]!
}

# For clarity between the CoA Account segment and the current KFS Account, we will refer to the CoA segment as "Natural Account", a commonly used accounting term.
#
# The (Natural) Account segment categorizes the nature of the transaction being recorded. The transaction is either revenue-producing, an expenditure, an asset that is owned, or a liability that is owed. Additionally, Account maintains Net Position for Entities and Funds.
#
# (Natural) Account values will generally be shared across Financial Departments to provide consistency in operational and management reporting for UC Davis.
#
# **FAU Value Comparison:**
#
# The (Natural) Account segment most closely aligns with the KFS Object Code.
type ErpAccount {
  # Unique identifier of an ErpAccount
  code: ErpAccountCode!

  # Internal numeric identifier of an ErpAccount
  id: Long!

  # Descriptive name of an ErpAccount
  name: NonEmptyTrimmedString240!

  # Whether this ErpAccount is presently enabled for use.
  enabled: Boolean!

  # The date from when the value is available for use.
  startDate: LocalDate

  # The date till which the value is available for use.
  endDate: LocalDate

  # Indicates that the ErpAccount is only used for summarization and may not be used on GL Entries
  summaryOnly: Boolean!

  # Indicates that data linked to this ErpAccount is protected by row-level security.
  securityEnabled: Boolean!

  # The number that indicates the order in which the values appear in the list of values.
  sortOrder: PositiveInt

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime!

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId

  # Code of the ErpAccount which is the immediate parent of this one.
  # Will be undefined if the ErpAccount has no parent.
  parentCode: ErpAccountCode

  # The ErpAccount which is the immediate parent of this one.
  # Will be undefined if the ErpAccount has no parent.
  parent: ErpAccount

  # The ErpAccounts which are the immediate children of this one.
  # Will be an empty list if the ErpAccount has no children.
  children: [ErpAccount!]

  # Level below the top for a ErpAccount that is part of a reporting hierarchy.
  hierarchyDepth: Int

  # Reporting Level designation based on the hierarchy depth.
  hierarchyLevel: String

  # Returns whether this ErpAccount is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the ErpAccount must:
  # * Be enabled
  # * Not be summaryOnly
  # * Have a startDate and endDate range which includes the given accountingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!

  # Whether GL segment strings using this account code require a purpose code.  All expenses require an assigned purpose code.  Purpose is optional on other types of transactions.
  #
  # Expense accounts are defined as those which descend from account 50000B.
  purposeRequired: Boolean!
}

# Data object used to run searches on ErpAccount
input ErpAccountFilterInput {
  searchCommon: SearchCommonInputs
  code: StringFilterInput
  name: StringFilterInput
  enabled: BooleanFilterInput
  summaryOnly: BooleanFilterInput
  hierarchyDepth: IntFilterInput
  hierarchyLevel: ErpCoaHierarchyLevel
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for ErpAccount
type ErpAccountSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ErpAccount!]!
}

# The Activity segment will track significant transactions which are recurring and take place at a point in time.
#
# **Expanded Definition and Criteria:**
#
# The Activity segment will track activities or events which support:
#
# - Financial Departments
# - and/or Programs
# - and/or GL-Only Projects.
#
# Activities need to be tracked and reported on because of their financial significance.
# Activity values will generally be shared across Financial Departments to provide consistency in operational and management reporting for UC Davis.
# Activity values are assigned by UC Davis.
#
# **Examples:**
#
# - Commencement
# - Student Orientation & Welcome Events
# - Fund Raising Campaigns
# - Symposiums/ Colloquiums
# - Student Advising
# - Professional Development/Awards
# - Student Competitions
# - Marketing & Media Campaigns
# - Recruitment & Relocation
# - Student Organizations & Sports Clubs
# - Campus-wide Activities (e.g. Picnic Day)
#
# **FAU Value Comparison:**
#
# Due to significant variations in how departments track activities in KFS, it is not possible to align the Activity segment with a KFS value.
type ErpActivity {
  # Unique identifier of an ErpActivity
  code: ErpActivityCode!

  # Internal numeric identifier of an ErpActivity
  id: Long!

  # Descriptive name of an ErpActivity
  name: NonEmptyTrimmedString240!

  # Whether this ErpActivity is presently enabled for use.
  enabled: Boolean!

  # The date from when the value is available for use.
  startDate: LocalDate

  # The date till which the value is available for use.
  endDate: LocalDate

  # Indicates that the ErpActivity is only used for summarization and may not be used on GL Entries
  summaryOnly: Boolean!

  # Indicates that data linked to this ErpActivity is protected by row-level security.
  securityEnabled: Boolean!

  # The number that indicates the order in which the values appear in the list of values.
  sortOrder: PositiveInt

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime!

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId

  # Code of the ErpActivity which is the immediate parent of this one.
  # Will be undefined if the ErpActivity has no parent.
  parentCode: ErpActivityCode

  # The ErpActivity which is the immediate parent of this one.
  # Will be undefined if the ErpActivity has no parent.
  parent: ErpActivity

  # The ErpActivitys which are the immediate children of this one.
  # Will be an empty list if the ErpActivity has no children.
  children: [ErpActivity!]

  # Level below the top for a ErpActivity that is part of a reporting hierarchy.
  hierarchyDepth: Int

  # Reporting Level designation based on the hierarchy depth.
  hierarchyLevel: String

  # Returns whether this ErpActivity is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the ErpActivity must:
  # * Be enabled
  # * Not be summaryOnly
  # * Have a startDate and endDate range which includes the given accountingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!
}

# Data object used to run searches on ErpActivity
input ErpActivityFilterInput {
  searchCommon: SearchCommonInputs
  code: StringFilterInput
  name: StringFilterInput
  enabled: BooleanFilterInput
  summaryOnly: BooleanFilterInput
  hierarchyDepth: IntFilterInput
  hierarchyLevel: ErpCoaHierarchyLevel
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for ErpActivity
type ErpActivitySearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ErpActivity!]!
}

# The Entity segment identifies the major UC system organizational units. These units generally require their own complete, separately audited financial statements to comply with external, regulatory reporting requirements (e.g., external audits, tax reporting), which cannot achieve compliance by using the audited financial statements issued by the Office of the President. Entity, however, will also provide high level management and operational reports.
#
# The balancing segment designation in Oracle Financials Cloud allows for net position (e.g., fund balance) to be calculated at the Entity level.
#
# Entities at all levels have unique reporting and/or external auditing needs that can only be met with an Entity level designation (e.g., UC Davis Health).
#
# **FAU Value Comparison:**
# The Entity segment most closely aligns with the KFS Chart (e.g. 3, H, L, P).
type ErpEntity {
  # Unique identifier of an ErpEntity
  code: ErpEntityCode!

  # Internal numeric identifier of an ErpEntity
  id: Long!

  # Descriptive name of an ErpEntity
  name: NonEmptyTrimmedString240!

  # Whether this ErpEntity is presently enabled for use.
  enabled: Boolean!

  # The date from when the value is available for use.
  startDate: LocalDate

  # The date till which the value is available for use.
  endDate: LocalDate

  # Indicates that the ErpEntity is only used for summarization and may not be used on GL Entries
  summaryOnly: Boolean!

  # Indicates that data linked to this ErpEntity is protected by row-level security.
  securityEnabled: Boolean!

  # The number that indicates the order in which the values appear in the list of values.
  sortOrder: PositiveInt

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime!

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId

  # Code of the ErpEntity which is the immediate parent of this one.
  # Will be undefined if the ErpEntity has no parent.
  parentCode: ErpEntityCode

  # The ErpEntity which is the immediate parent of this one.
  # Will be undefined if the ErpEntity has no parent.
  parent: ErpEntity

  # The ErpEntitys which are the immediate children of this one.
  # Will be an empty list if the ErpEntity has no children.
  children: [ErpEntity!]

  # Level below the top for a ErpEntity that is part of a reporting hierarchy.
  hierarchyDepth: Int

  # Reporting Level designation based on the hierachy depth.
  hierarchyLevel: String

  # Returns whether this ErpEntity is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the ErpEntity must:
  # * Be enabled
  # * Not be summaryOnly
  # * Have a startDate and endDate range which includes the given accountingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!
}

# Data object used to run searches on ErpEntity
input ErpEntityFilterInput {
  searchCommon: SearchCommonInputs
  code: StringFilterInput
  parentCode: StringFilterInput
  name: StringFilterInput
  enabled: BooleanFilterInput
  summaryOnly: BooleanFilterInput
  hierarchyDepth: IntFilterInput
  hierarchyLevel: ErpCoaHierarchyLevel
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for ErpEntity
type ErpEntitySearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ErpEntity!]!
}

# Financial Department is often known as the "cost center" or "department". This field records, tracks and retains the Financial Department's financial transactions. There are several levels of Financial Departments within the CoA hierarchy. The mid-level hierarchy aligns with the UCPath HR Departments.
#
# **Financial Departments have:**
# - An ongoing business objective and operational function with no planned end date (enabling historical trend analysis + long-range planning)
#
# - Identifiable, permanently funded employees and generally an allocation of physical space
#
# **FAU Value Comparison:**
# Due to significant variations in departments' financial structure in KFS, it is not possible to align the Financial Department segment with  specific KFS values.
#
# **Access Roles: erp:reader-refdata**
type ErpFinancialDepartment {
  # Unique identifier of an ErpFinancialDepartment
  code: ErpDepartmentCode!

  # Internal numeric identifier of an ErpFinancialDepartment
  id: Long!

  # Descriptive name of an ErpFinancialDepartment
  name: NonEmptyTrimmedString240!

  # Whether this ErpFinancialDepartment is presently enabled for use.
  enabled: Boolean!

  # The date from when the value is available for use.
  startDate: LocalDate

  # The date till which the value is available for use.
  endDate: LocalDate

  # Indicates that the ErpFinancialDepartment is only used for summarization and may not be used on GL Entries
  summaryOnly: Boolean!

  # Indicates that data linked to this ErpFinancialDepartment is protected by row-level security.
  securityEnabled: Boolean!

  # The number that indicates the order in which the values appear in the list of values.
  sortOrder: PositiveInt

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime!

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId

  # Code of the ErpFinancialDepartment which is the immediate parent of this one.
  # Will be undefined if the ErpFinancialDepartment has no parent.
  parentCode: ErpDepartmentCode

  # The ErpFinancialDepartment which is the immediate parent of this one.
  # Will be undefined if the ErpFinancialDepartment has no parent.
  parent: ErpFinancialDepartment

  # The ErpFinancialDepartments which are the immediate children of this one.
  # Will be an empty list if the ErpFinancialDepartment has no children.
  children: [ErpFinancialDepartment!]!

  # Level below the top for a ErpFinancialDepartment that is part of a reporting hierarchy.
  hierarchyDepth: Int

  # Reporting Level designation based on the hierarchy depth.
  hierarchyLevel: String

  # Reporting Level designation based on the hierarchy depth.
  departmentType: ErpDepartmentTypeCode

  # Fiscal Officer: Display Name of the assigned fiscal officer for expenses charged to this department.
  fiscalOfficerName: NonEmptyTrimmedString240

  # Returns whether this ErpFinancialDepartment is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the ErpFinancialDepartment must:
  # * Be enabled
  # * Not be summaryOnly
  # * Have a startDate and endDate range which includes the given accountingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!
}

# Data object used to run searches on ErpFinancialDepartment objects
input ErpFinancialDepartmentFilterInput {
  searchCommon: SearchCommonInputs
  code: StringFilterInput
  name: StringFilterInput
  fiscalOfficerName: StringFilterInput
  enabled: BooleanFilterInput
  summaryOnly: BooleanFilterInput
  hierarchyDepth: IntFilterInput
  hierarchyLevel: ErpCoaHierarchyLevel
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for ErpFinancialDepartment
type ErpFinancialDepartmentSearchResults {
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ErpFinancialDepartment!]!
}

# Funds provide a method of tracking funding resources whose use is limited by donors, granting agencies, regulations and other external individuals or entities, or by governing boards. A Fund is maintained for each specific funding type (e.g., Unrestricted, Restricted-Expendable, Capital) which supports the compilation of GASB audited financial statements.
#
# The balancing segment designation in Oracle Financials Cloud allows for net position (e.g., fund balance) to be calculated at the Fund level.
#
# In most cases, Fund activity will be presented in the general ledger in summary and the Fund values will be shared amongst Financial Departments. For example, all Financial Departments will share one Restricted Expendable Federal Contracts fund. The detailed transactional information related to each federally sponsored project within this fund will be tracked using the PPM module.
#
# **FAU Value Comparison:**
# The Fund segment most closely aligns with the fund attribute of the KFS Account.
type ErpFund {
  # Unique identifier of an ErpFund
  code: ErpFundCode!

  # Internal numeric identifier of an ErpFund
  id: Long!

  # Descriptive name of an ErpFund
  name: NonEmptyTrimmedString240!

  # Whether this ErpFund is presently enabled for use.
  enabled: Boolean!

  # The date from when the value is available for use.
  startDate: LocalDate

  # The date till which the value is available for use.
  endDate: LocalDate

  # Indicates that the ErpFund is only used for summarization and may not be used on GL Entries
  summaryOnly: Boolean!

  # Indicates that data linked to this ErpFund is protected by row-level security.
  securityEnabled: Boolean!

  # The number that indicates the order in which the values appear in the list of values.
  sortOrder: PositiveInt

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime!

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId

  # Code of the ErpFund which is the immediate parent of this one.
  # Will be undefined if the ErpFund has no parent.
  parentCode: ErpFundCode

  # The ErpFund which is the immediate parent of this one.
  # Will be undefined if the ErpFund has no parent.
  parent: ErpFund

  # The ErpFunds which are the immediate children of this one.
  # Will be an empty list if the ErpFund has no children.
  children: [ErpFund!]!

  # Level below the top for a ErpFund that is part of a reporting hierarchy.
  hierarchyDepth: Int

  # Reporting Level designation based on the hierachy depth.
  hierarchyLevel: String

  # Whether this fund is used for budgeting purposes.
  budgeted: Boolean

  # Returns whether this ErpFund is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the ErpFund must:
  # * Be enabled
  # * Not be summaryOnly
  # * Have a startDate and endDate range which includes the given accountingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!
}

# Data object used to run searches on ErpFund
input ErpFundFilterInput {
  searchCommon: SearchCommonInputs
  code: StringFilterInput
  name: StringFilterInput
  enabled: BooleanFilterInput
  summaryOnly: BooleanFilterInput
  budgeted: BooleanFilterInput
  hierarchyDepth: IntFilterInput
  hierarchyLevel: ErpCoaHierarchyLevel
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for ErpFund
type ErpFundSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ErpFund!]!
}

# The Program segment records revenue and expense transactions associated with a formal, ongoing system-wide or cross-campus/location academic or administrative activity that demonstrates UC Davis' mission of teaching, research, public service and patient care.
#
# **Expanded Definition and Criteria:**
# There are two categories of Programs:
# 1. Those pre-defined and sanctioned by UCOP, of which values are predesignated
# 2. Those endorsed and acknowledged by UC Davis Leadership
#
# Programs have permanence, are a going-concern, and are considered significant due to their prominence and impact.
#
# In general, Programs have allocated, not dedicated, FTEs and cannot be identified through a single Financial Department, Project Code or Activity Code.
#
# Program values are determined by both UCOP and UC Davis.
#
# **Examples:**
#
# * UCOP System-wide examples:
#   * Ag Experiment Station (AES)
#   * California State Summer School for Mathematics & Science (COSMOS)
#   * UC Sacramento
# * UC Davis examples (possible programs):
#   * Self-Supporting Degree Programs
#   * Student Success Programs
#   * Graduate Groups
#   * Campus-wide Programs
#   * Campus Ready
#   * Healthy Davis Together
#   * International/ Study Abroad Programs
#   * Housing Services Programs
#
# **FAU Value Comparison:**
# Due to significant variations in how departments track programs in KFS, it is not possible to align the Program segment with a KFS value.
type ErpProgram {
  # Unique identifier of an ErpProgram
  code: ErpProgramCode!

  # Internal numeric identifier of an ErpProgram
  id: Long!

  # Descriptive name of an ErpProgram
  name: NonEmptyTrimmedString240!

  # Whether this ErpProgram is presently enabled for use.
  enabled: Boolean!

  # The date from when the value is available for use.
  startDate: LocalDate

  # The date till which the value is available for use.
  endDate: LocalDate

  # Indicates that the ErpProgram is only used for summarization and may not be used on GL Entries
  summaryOnly: Boolean!

  # Indicates that data linked to this ErpProgram is protected by row-level security.
  securityEnabled: Boolean!

  # The number that indicates the order in which the values appear in the list of values.
  sortOrder: PositiveInt

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime!

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId

  # Code of the ErpProgram which is the immediate parent of this one.
  # Will be undefined if the ErpProgram has no parent.
  parentCode: ErpProgramCode

  # The ErpProgram which is the immediate parent of this one.
  # Will be undefined if the ErpProgram has no parent.
  parent: ErpProgram

  # The ErpPrograms which are the immediate children of this one.
  # Will be an empty list if the ErpProgram has no children.
  children: [ErpProgram!]

  # Level below the top for a ErpProgram that is part of a reporting hierarchy.
  hierarchyDepth: Int

  # Reporting Level designation based on the hierachy depth.
  hierarchyLevel: String

  # Returns whether this ErpProgram is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the ErpProgram must:
  # * Be enabled
  # * Not be summaryOnly
  # * Have a startDate and endDate range which includes the given accountingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!
}

# Data object used to run searches on ErpProgram
input ErpProgramFilterInput {
  searchCommon: SearchCommonInputs
  code: StringFilterInput
  name: StringFilterInput
  enabled: BooleanFilterInput
  summaryOnly: BooleanFilterInput
  hierarchyDepth: IntFilterInput
  hierarchyLevel: ErpCoaHierarchyLevel
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for ErpProgram
type ErpProgramSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ErpProgram!]!
}

# The Project segment tracks financial activity for a "body of work" that often has a start and an end date that spans across fiscal years.
#
# **Expanded Definition and Criteria:**
#
# There are two categories of Projects:
#
# 1. GL-Only Projects
# 2. Projects supported with the PPM (Projects Portfolio Management).
#
# GL-Only Projects - Activities, initiatives, or bodies of work with explicit funding, low complexity of budget management and/or reporting needs, &         which are not explicitly defined as a PPM Project.
#
# - Are associated with a Financial Department, and are formally recognized and of financial significance.
# - Billing/invoicing to a third party is not required.
#
# PPM Projects - Generally, a body of work, often supported by a contract, with complex budget and third-party invoicing needs, or designated to a         specific faculty member by agreement.
#
# - Generally, have a designated start and end date.
# - Managed under the terms and conditions of a contract.
# - Supported by multi-funding sources.
# - Supports reporting across fiscal years.
#
# **FAU Value Comparison:**
#
# Due to significant variations in how departments track projects in KFS, it is not possible to align the Project segment with a KFS value.
type ErpProject {
  # Unique identifier of an ErpProject
  code: ErpProjectCode!

  # Internal numeric identifier of an ErpProject
  id: Long!

  # Descriptive name of an ErpProject
  name: NonEmptyTrimmedString240!

  # Whether this ErpProject is presently enabled for use.
  enabled: Boolean!

  # The date from when the value is available for use.
  startDate: Date

  # The date till which the value is available for use.
  endDate: Date

  # Indicates that the ErpProject is only used for summarization and may not be used on GL Entries
  summaryOnly: Boolean!

  # Indicates that data linked to this ErpProject is protected by row-level security.
  securityEnabled: Boolean!

  # The number that indicates the order in which the values appear in the list of values.
  sortOrder: PositiveInt

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId

  # Code of the ErpProject which is the immediate parent of this one.
  # Will be undefined if the ErpProject has no parent.
  parentCode: ErpProjectCode

  # The ErpProject which is the immediate parent of this one.
  # Will be undefined if the ErpProject has no parent.
  parent: ErpProject

  # The ErpProjects which are the immediate children of this one.
  # Will be an empty list if the ErpProject has no children.
  children: [ErpProject!]

  # Level below the top for a ErpProject that is part of a reporting hierarchy.
  hierarchyDepth: Int

  # Reporting Level designation based on the hierachy depth.
  hierarchyLevel: String

  # Whether this is a PPM project or a GL Only project.  Only GL-only projects may be expensed directly on a journal feed.  PPM Projects must be expensed via the POET strings via the ppmSegments inputs on the journal or distribution lines.
  isPpmProject: Boolean

  # If a project code represents a PPM Project, this property will be a reference to that project.
  ppmProject: PpmProject

  # Returns whether this ErpProject is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the ErpProject must:
  # * Be enabled
  # * Not be summaryOnly
  # * Have a parentCode of GLG000000A (parent of all GL-only projects)
  # * Have a startDate and endDate range which includes the given accountingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!
}

# Data object used to run searches on ErpProject
input ErpProjectFilterInput {
  searchCommon: SearchCommonInputs
  code: StringFilterInput
  name: StringFilterInput
  enabled: BooleanFilterInput
  summaryOnly: BooleanFilterInput
  hierarchyDepth: IntFilterInput
  hierarchyLevel: ErpCoaHierarchyLevel
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for ErpProject
type ErpProjectSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ErpProject!]!
}

# The Purpose segment tracks the purpose of the transaction, such as NACUBO-defined functional expense classification and mission.
#
# NACUBO classification data is utilized for far-reaching external reporting (e.g., institution ranking). This field is also essential for compliance with federal cost principles and financial statement reporting requiring expenditures be displayed by functional class.
#
# **FAU Value Comparison:**
#
# The Purpose segment most closely aligns with the HEFC (Higher Ed. Function Code) attribute of the KFS Account.
type ErpPurpose {
  # Unique identifier of an ErpPurpose
  code: ErpPurposeCode!

  # Internal numeric identifier of an ErpPurpose
  id: Long!

  # Descriptive name of an ErpPurpose
  name: NonEmptyTrimmedString240!

  # Whether this ErpPurpose is presently enabled for use.
  enabled: Boolean!

  # The date from when the value is available for use.
  startDate: LocalDate

  # The date till which the value is available for use.
  endDate: LocalDate

  # Indicates that the ErpPurpose is only used for summarization and may not be used on GL Entries
  summaryOnly: Boolean!

  # Indicates that data linked to this ErpPurpose is protected by row-level security.
  securityEnabled: Boolean!

  # The number that indicates the order in which the values appear in the list of values.
  sortOrder: PositiveInt

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime!

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId

  # Code of the ErpPurpose which is the immediate parent of this one.
  # Will be undefined if the ErpPurpose has no parent.
  parentCode: ErpPurposeCode

  # The ErpPurpose which is the immediate parent of this one.
  # Will be undefined if the ErpPurpose has no parent.
  parent: ErpPurpose

  # The ErpPurposes which are the immediate children of this one.
  # Will be an empty list if the ErpPurpose has no children.
  children: [ErpPurpose!]

  # Level below the top for a ErpPurpose that is part of a reporting hierarchy.
  hierarchyDepth: Int

  # Reporting Level designation based on the hierachy depth.
  hierarchyLevel: String

  # Returns whether this ErpPurpose is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the ErpPurpose must:
  # * Be enabled
  # * Not be summaryOnly
  # * Have a startDate and endDate range which includes the given accountingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!
}

# Data object used to run searches on ErpPurpose
input ErpPurposeFilterInput {
  searchCommon: SearchCommonInputs
  code: StringFilterInput
  name: StringFilterInput
  enabled: BooleanFilterInput
  summaryOnly: BooleanFilterInput
  hierarchyDepth: IntFilterInput
  hierarchyLevel: ErpCoaHierarchyLevel
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for ErpPurpose
type ErpPurposeSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ErpPurpose!]!
}

# String limited to 1000 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString1000

# String limited to 360 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString360

# String limited to 320 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString320

# String limited to 240 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString240

# String limited to 255 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString255

# String limited to 250 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString250

# String limited to 225 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString225

# String limited to 150 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString150

# String limited to 100 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString100

# String limited to 80 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString80

# String limited to 60 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString60

# String limited to 50 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString50

# String limited to 40 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString40

# String limited to 32 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString32

# Trimmed String limited to 30 characters.
scalar NonEmptyTrimmedString30

# String limited to 25 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString25

# Trimmed String limited to 20 characters.
scalar NonEmptyTrimmedString20

# String limited to 15 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString15

# String limited to 10 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString10

# String limited to 4 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString4

# String limited to 3 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString3

# String limited to 2 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString2

# String limited to 1 characters.  Whitespace will be trimmed from both ends of the string when passing in both directions.  In the case that source data to be returned by the API exceeds this length, it will be truncated.
scalar NonEmptyTrimmedString1

# Status options within the [ActionRequestStatus]({{Types.ActionRequestStatus}}) that reflect the states a request can be in.
enum RequestStatus {
  # Request has been submitted to the server, but not validated or processed.
  PENDING

  # Request has been picked up for processing.
  INPROCESS

  # There was an error processing the request after it was picked up.
  ERROR

  # Request has been processed, but the callback has not been completed.
  PROCESSED

  # If Callback URL Provided: Request has been processed, and the callback was successfully contacted.  Or, request has been processed, and no callback URL was provided.
  COMPLETE

  # If Callback URL Provided: Request has been processed, but repeated attempts to contact the callback have failed and no more will be tried.
  STALE

  # There was a validation error in the request payload data.
  REJECTED
}

# Fields common to all action requests.
input ActionRequestHeaderInput {
  # Identifier provided by the consumer to track requests internally.  It is recommended that this be a globally unique identfier tracked in their system.  Can be used to match up data in the caller's system.
  consumerTrackingId: NonEmptyTrimmedString80!

  # Identifier provided by the consumer which usually references the source record within their system.  Does not need to be unique.
  consumerReferenceId: NonEmptyTrimmedString80!

  # Any notes to include with the request, this is stored as metadata to provide context to the request.
  consumerNotes: NonEmptyTrimmedString240

  # Identifier for the boundary application originating the request.
  boundaryApplicationName: NonEmptyTrimmedString80!

  # ID of the consumer which must match the authentication data.  Not required for API calls as will be filled in by the server.
  consumerId: NonEmptyTrimmedString80

  # If set to true, allows processing of this request to be delayed and combined with other compatible requests if supported by the request type.  It will be ignored if not supported.  Length of delay and pickup time is determined during integration processing.
  batchRequest: Boolean
}

# Fields common to all action status requests.
type ActionRequestStatus {
  # Unique identifier assigned to the request
  requestId: UUID

  # ID of the consumer who made the request extracted from the service authentication data
  consumerId: NonEmptyTrimmedString80!

  # Identifier provided by the consumer to track requests internally.  It is recommended that this be a globally unique identfier tracked in their system.  Can be used to match up data in the caller's system.
  consumerTrackingId: NonEmptyTrimmedString80!

  # Identifier provided by the consumer which usually references the source record within their system.  Does not need to be unique.
  consumerReferenceId: NonEmptyTrimmedString80!

  # Any notes to include with the request, this is stored as metadata to provide context to the request.
  consumerNotes: NonEmptyTrimmedString240

  # Identifier for the boundary application originating the request.
  boundaryApplicationName: NonEmptyTrimmedString80!

  # Name of the operation called.
  operationName: String!
  requestDateTime: DateTime!
  requestStatus: RequestStatus!

  # When the status last changed
  lastStatusDateTime: DateTime!

  # When the request was processed by the ERP system
  processedDateTime: DateTime

  # Error information if the request failed during processing.
  errorMessages: [String!]

  # GraphQL Payload to post back to this server to check on the status of the request.
  statusRequestPayload: JSON

  # Original action request payload for this request.
  actionRequestPayload: JSON

  # Additional identifiers and/or status information extracted from the downstream system during or after processing.  This property may not be filled in until some time after the process has completed, as data may have to be retrieved from scheduled data extracts.
  resultAttributes: JSON
}

# Status of the pipeline request triggered from an API action request.
enum ProcessingResultStatus {
  # data is in pipeline for processing and all jobs have not completed
  INPROCESS

  # processing is complete but notifications have not been sent
  PROCESSED

  # all jobs completed successfully
  SUCCESS

  # one or more of the jobs resulted in an error and was not processed
  ERROR
}

# Result of the attempt to process the action request in the destination system
type ProcessingResult {
  status: String!
  requestDateTime: DateTime!
  lastStatusCheckDateTime: DateTime

  # Time the request was noted as completed processing, whether successful or not.
  processedDateTime: DateTime

  # Any error messages generated during processing.
  errorMessages: String

  # List of the individual destination-system jobs that were required to process this request.
  jobs: [RequestJobResult!]
}

# Results of the job as submitted to the ERP system.
type RequestJobResult {
  # Identifier of the type of job submitted.
  jobId: String!

  # Current status of the oracle job.
  jobStatus: String!

  # Optional value which the pipeline generates as part of the data file to identify the records that need to be processed.  This is the Group ID for GL entries and the Batch Name for PPM Costs.  Not all jobs will have a value to place here.
  assignedJobId: String

  # Job report or log output from executing the request on the ERP system.
  jobReport: String

  # Records which caused the job to fail.
  failedRecords: String

  # Time the job completion was recorded.
  completedDateTime: DateTime
}

# Contains the validation overall status and any error messages and the properties they belong to.
type ValidationResponse {
  # Whether the overall validation succeeded or failed.
  valid: Boolean!

  # Array of all errors found during validation.  The failed property is in the matching index in the `messageProperties` list.
  errorMessages: [String!]

  # Property names which failed validation.  May be blank if the validation applies to the entire payload or no particular property.
  messageProperties: [String!]
}

type SegmentWarning {
  # Name of the segment per the property name in the GlSegments or PpmSegments types.
  segmentName: String!

  # Warning message associated with the use of the given segment.
  warning: String!
}

# Valid end date for a given segment in a GL or PPM chartstring.
type SegmentEndDate {
  # Name of the segment per the property name in the GlSegments or PpmSegments types.
  segmentName: String!

  # End date of the given segment as defined in the associated table.
  endDate: LocalDate!
}

# Oracle GL Entity Segment Code
#
# Represents the 4-character entity code that identifies the major operational unit within the University of California responsible for each transaction.
#
# * All values are exactly 4 characters matching the regex pattern: `[0-9]{3}[0-9AB]`
# * Validated against the [`ErpEntity`]({{Types.ErpEntity}}) object.
scalar ErpEntityCode

# Oracle GL Fund Segment Code
#
# * All values are exactly 5 characters matching the regex pattern: `[0-9A-Z]{5}`
# * Validated against the [`ErpFund`]({{Types.ErpFund}}) object.
scalar ErpFundCode

# Oracle GL Financial Department Segment Code
#
# * All values are exactly 7 characters matching the regex pattern: `[0-9A-Z]{7}`
# * Validated against the [`ErpFinancialDepartment`]({{Types.ErpFinancialDepartment}}) object.
scalar ErpDepartmentCode

# Oracle GL Purpose Segment Code
#
# * All values are exactly 2 characters matching the regex pattern: `[0-9][0-9A-Z]`
# * Validated against the [`ErpPurpose`]({{Types.ErpPurpose}}) object.
scalar ErpPurposeCode

# Oracle GL Account Segment Code
#
# * All values are exactly 6 characters matching the regex pattern: `[0-9A-Z]{6}`
# * Validated against the [`ErpAccount`]({{Types.ErpAccount}}) object.
scalar ErpAccountCode

# Oracle GL Activity Segment Code
#
# * All values are exactly 6 characters matching the regex pattern: `[0-9A-Z]{6}`
# * Validated against the [`ErpActivity`]({{Types.ErpActivity}}) object.
scalar ErpActivityCode

# Oracle GL Program Segment Code
#
# * All values are exactly 3 characters matching the regex pattern: `[0-9A-Z]{3}`
# * Validated against the [`ErpProgram`]({{Types.ErpProgram}}) object.
scalar ErpProgramCode

# Oracle GL Project Segment Code
#
# * All values are exactly 10 characters matching the regex pattern: `[0-9A-Z]{10}`
# * Validated against the [`ErpProject`]({{Types.ErpProject}}) object.
scalar ErpProjectCode

# Oracle GL Flex1 Segment Code - **UNUSED**
scalar ErpFlex1Code

# Oracle GL Flex2 Segment Code - **UNUSED**
scalar ErpFlex2Code

# Oracle Accounting Period Name
#
# * Validated against the `periodName` of the [`GlAccountingPeriod`]({{Types.GlAccountingPeriod}}).
#
scalar ErpAccountingPeriodName

# Oracle User ID: 32 character limit
scalar ErpUserId

# ERP Financial Department Type Code
scalar ErpDepartmentTypeCode

# Oracle Managed Project Number
#
# A 10-character project code which identifies Sponsored Research, a Faculty Portfolio, or a Capital Project.  Values will generally start with a 2 character prefix which identifies their type followed by a system-assigned number.
#
# **Definition:** The Project identifies the planned work or activity to be completed over a period of time and intended to achieve a particular goal.
#
# **Roll-up relationship to the new Chart of Accounts (CoA) in the General Ledger:**
# * The POET(AF) Project value will roll up to the Project segment of the Chart of Accounts.
# * PPM Project values and GL Project segment values will be the same.
#
scalar PpmProjectNumber

# Oracle PPM Expense Organization
#
# The PPM Expense organization will have the same values as the [`ErpFinancialDepartment`]({{Types.ErpFinancialDepartment}}).  The expected value by oracle is the code + " - " + name.  This API will accept the code alone by using the first 7 characters of the string and perfoming the needed lookup to obtain the value required by Oracle.
#
# **Definition:** The Expenditure Organization identifies the organization that is incurring the expense and revenue. This may NOT be the same as the organization that owns the project.
#
# **Roll-up relationship to the new Chart of Accounts in the General Ledger:**
# * The Expenditure Organization value will roll up to the Financial Department segment of the Chart of Accounts.
#
scalar PpmExpenseOrganizationCode

# Oracle PPM Expense Type
#
# The PPM Expense Type will have the same values as the [`ErpAccount`]({{Types.ErpAccount}}).  The expected value by oracle is the code + " - " + name.  This API will accept the code alone by using the first 6 characters of the string and perfoming the needed lookup to obtain the value required by Oracle.
#
# **Definition:** The Expenditure Type identifies the natural classification of the expense transaction being recorded.
#
# **Roll-up relationship to the new Chart of Accounts in the General Ledger:**
# * The Expenditure Type value will roll up to the (Natural) Account segment in the Chart of Accounts.
# * The first 6 characters of the Expenditure Type value will correspond with the (Natural) Account value it rolls up to.
#
scalar PpmExpenseTypeCode

# Oracle PPM Project Task
#
# The task number is a 4-character code which identifies an activity within a project.  PPM will internally map this to a combination of other segments during sub-ledger accounting processing to post to the GL.
#
# **Definition:** The Task identifies the activities used to further breakdown a PPM project. Every project MUST have at least one Task.  The number of tasks will vary by type of project.
#
# **Roll-up relationship to the new Chart of Accounts in the General Ledger:**
# * Task values are exclusively used in the PPM module.
# * For Internal Faculty Projects, the Task will identify the Program, Purpose, Fund and Activity segments in the GL, using various PPM mapping rules.
#
scalar PpmTaskNumber

# Oracle PPM Award Number
#
# Only required for Sponsored Research projects (defined as a flag on the [PpmProject]({{Types.PpmProject}})), this identifies the award to which the expenses are applied.  This will be an system-generated 7-character string.  It is for project reporting only, and has no impact on the GL mappings.
#
# Normally, you will not need to provide this, as most projects will have a single award and this will be derived by the API.  File-based submitters will need to look up the default project number from the PpmProject and supply it when the `sponsoredProject` property is true.
#
scalar PpmAwardNumber

# Oracle PPM Funding Source Number
#
# Only required for Sponsored Research projects (defined as a flag on the [PpmProject]({{Types.PpmProject}})), this identifies the funding to which the expenses are applied.  It will be used to derive the GL Fund segment.
#
# **FORMAT AND LENGTH OF THIS SEGMENT IS UNKNOWN AT THIS TIME (4/4/22)**
#
# Normally, you will not need to provide this, as most projects will have a single funding source and this will be derived by the API.  File-based submitters will need to look up the default project number from the PpmProject and supply it when the `sponsoredProject` property is true.
#
scalar PpmFundingSourceNumber

# Oracle PPM Combined Segments Chartstring
#
# Must be populated with either the 4 required segments, or all 6 segments.  (Project-Task Number-Expense Organization-Expense Type-Award Number-Funding Source)
#
# * Format Pattern (Required Only): `SP00000001-000001-0000000-000000`
# * Format Pattern (Sponsored Projects): `CP00000001-000001-0000000-000000-0000000-00000`
# * Format Regex:   `^[0-9A-Z]{10}-[0-9A-Z]{6}-[0-9A-Z]{7}-[0-9A-Z]{6}(-[0-9A-Z]{7}-[0-9A-Z]{5})?$`
#
# See documentation on the individual segments for more information:
#
# * [PpmProjectNumber]({{Types.PpmProjectNumber}})
# * [PpmExpenseOrganizationCode]({{Types.PpmExpenseOrganizationCode}})
# * [PpmExpenseTypeCode]({{Types.PpmExpenseTypeCode}})
# * [PpmTaskNumber]({{Types.PpmTaskNumber}})
# * [PpmAwardNumber]({{Types.PpmAwardNumber}})
# * [PpmFundingSourceNumber]({{Types.PpmFundingSourceNumber}})
#
scalar PpmSegmentString

# General Ledger Journal Category Key
#
# * Limit of 25 characters.
# * Validated against the `key` of the [`GlJournalCategory`]({{Types.GlJournalCategory}}).
#
scalar GlJournalCategoryKey

# General Ledger Journal Source Key or Name
#
# * Limit of 25 characters.
# * Validated against the `key` of the [`GlJournalSource`]({{Types.GlJournalSource}}).
#
scalar GlJournalSourceKey

# Oracle GL Combined Segments Chartstring
#
# Must be fully populated with all 11 segments, even if unused.  Fill unused segments with zeroes.
#
# * Format Pattern: `0000-00000-0000000-000000-00-000-0000000000-000000-0000-000000-000000`
# * Format Regex:   `^[0-9]{3}[0-9AB]-[0-9A-Z]{5}-[0-9A-Z]{7}-[0-9A-Z]{6}-[0-9][0-9A-Z]-[0-9A-Z]{3}-[0-9A-Z]{10}-[0-9A-Z]{6}-0000-000000-000000$`
#
scalar GlSegmentString

# 10-character reference field limited to letters, numbers, hyphen, and underscore
scalar GlReferenceField10

# 25-character reference field limited to letters, numbers, hyphen, and underscore
scalar GlReferenceField25

# 40-character description field limited to letters, numbers, hyphen, underscore, and spaces
scalar GlDescriptionField40

# 100-character naming field limited to letters, numbers, hyphen, underscore, and spaces
scalar ErpNameField100

# Up to 240-character description field limited to letters, numbers, hyphen, underscore, spaces, and periods.
scalar ErpDescriptionField240

# 7-character KFS Account Number, upper-case letters and digits only
scalar KfsAccountNumber

# 1-character KFS Chart Code.  Must be one of 3, L, H, S, P, M, N
scalar KfsChartCode

# 4-character KFS Org Code, upper-case letters and digits only
scalar KfsOrgCode

# 10-character KFS Project Code, upper-case letters and digits only
scalar KfsProjectCode

# 5-character KFS Sub Account Number, upper-case letters and digits only
scalar KfsSubAccountNumber

# Oracle SCM Name
scalar ScmName

# Oracle Country Code.  ISO-3601-1 alpha-2
scalar ErpCountryCode

# Oracle City Name, 60-character limit
scalar CityName

# Oracle SCM Address Line, 240 Character Limit
scalar ScmAddressLine

# Oracle Postal Code
scalar ErpPostalCode

# Oracle Email Address, 320 Character Limit
scalar ErpEmailAddress

# Oracle ERP Unit Of Measure Code
scalar ErpUnitOfMeasureCode

# Hierarchy Level Codes used in the financial chartstring structures.
enum ErpCoaHierarchyLevel {
  # Top Level, Defined by UCOP
  X

  # Second Level, often defined by UCOP for segments with many values.
  A

  # Third Level, campus-specific, but may be UCOP defined.
  B

  # Fourth Level: Usually campus-defined values here and below.
  C

  # Fifth Level
  D

  # Sixth Level
  E

  # Seventh Level
  F
}

# Used on AR Invoices to indicate the type of accounting on a distribution line.
enum ArAccountClass {
  # Revenue
  REV

  # Receivable
  REC
}

enum ArTransactionType {
  # Normal Receivables Line.  Excludes tax, freight, or misc charges.
  LINE

  # Charged Tax Line
  TAX

  # Shipping and Handling Charges Line
  FREIGHT

  # Other Charges Line
  CHARGES
}

# Used on payment API to indicate payment type
enum PayeeType {
  SUPPLIER
  STUDENT
  EMPLOYEE
}

# Invoice category used in Payable Payment
enum InvoiceType {
  STANDARD
  CREDIT
  PREPAYMENT
}

# Input structure for specifying GL segment values as separate fields.
input GlSegmentInput {
  # Required: Entity to which to charge a transaction.
  entity: ErpEntityCode!

  # Required: Funding source to which to charge a transaction.
  fund: ErpFundCode!

  # Required: Financial department to which to charge a transaction.
  department: ErpDepartmentCode!

  # Required: Nature of the transaction, expense, income, liability, etc...
  account: ErpAccountCode!

  # Required for Expenses: Functional purpose of the expense.
  purpose: ErpPurposeCode

  # Optional:
  project: ErpProjectCode

  # Optional:
  program: ErpProgramCode

  # Optional:
  activity: ErpActivityCode

  # Unused: For future UCOP Reporting Requirements.  Always 000000.
  flex1: ErpFlex1Code

  # Unused: For future UCOP Reporting Requirements.  Always 000000.
  flex2: ErpFlex2Code
}

# GL segment values as separate fields.
type GlSegments {
  # Required: Entity to which to charge a transaction.
  entity: ErpEntityCode

  # Required: Funding source to which to charge a transaction.
  fund: ErpFundCode

  # Required: Financial department to which to charge a transaction.
  department: ErpDepartmentCode

  # Required for Expenses: Functional purpose of the expense.
  purpose: ErpPurposeCode

  # Required: Nature of the transaction, expense, income, liability, etc...
  account: ErpAccountCode

  # Optional:
  project: ErpProjectCode

  # Optional:
  program: ErpProgramCode

  # Optional:
  activity: ErpActivityCode
}

# Input structure for specifying POET/PPM segment values.
input PpmSegmentInput {
  # Required: Managed Project Number
  project: PpmProjectNumber!

  # Required: Task ID.  Must belong to Project and be a chargeable task
  task: PpmTaskNumber!

  # Required: Organization for which the expense is being incurred.  Aligns with the GL Financial Department segment.
  organization: PpmExpenseOrganizationCode!

  # Required: Type of expense being charged to the project.  Aligns with the GL Account segment.
  expenditureType: PpmExpenseTypeCode!

  # Award for Sponsored projects only
  #
  # **API Users, do not provide.  The valid value will be derived from the project if necessary.**
  award: PpmAwardNumber

  # Award funding source for Sponsored projects only
  #
  # **API Users, do not provide.  The valid value will be derived from the project if necessary.**
  fundingSource: PpmFundingSourceNumber
}

type GlSegmentNames {
  entityName: String
  fundName: String
  departmentName: String
  accountName: String
  purposeName: String
  projectName: String
  programName: String
  activityName: String
}

# POET/PPM segment values.
type PpmSegments {
  # Required: Managed Project Number
  project: PpmProjectNumber!

  # Required: Task ID.  Must belong to Project and be a chargeable task
  task: PpmTaskNumber!

  # Required: Organization for which the expense is being incurred.  Aligns with the GL Financial Department segment.
  organization: PpmExpenseOrganizationCode!

  # Required: Type of expense being charged to the project.  Aligns with the GL Account segment.
  expenditureType: PpmExpenseTypeCode!

  # Award for Sponsored projects only
  award: PpmAwardNumber

  # Award funding source for Sponsored projects only
  fundingSource: PpmFundingSourceNumber
}

# Special properties common to all common search operations.
input SearchCommonInputs {
  # Array of property names to sort on
  sort: [String!]

  # maximum number of records to retrieve
  limit: PositiveInt

  # Record number to start with
  startIndex: NonNegativeInt

  # Whether to include a count of all records to be returned by this search.  Will increase search time.
  includeTotalResultCount: Boolean
}

# Metadata about the search results returned in a given response.
# Used to provide metrics of the results and the information necessary
# to pull in the next set of records.
type SearchResultMetadata {
  # Array of property names used to sort the results
  sort: [String!]

  # requested limit to the number of records to retrieve
  limit: PositiveInt

  # Results returned in the data property.
  returnedResultCount: NonNegativeInt!

  # Starting index for the current result set.
  startIndex: NonNegativeInt!

  # Start index for getting the next page of results.  Unset if there are no more results.
  nextStartIndex: NonNegativeInt

  # Total number of results.  Will only be populated if `includeTotalResultCount` is true in the search request.
  totalResultCount: NonNegativeInt
}

# String filter criteria object, only one of this object's properties should be set.  Except as noted in the properties below, all comparisons are case-sensitive.
input StringFilterInput {
  # Test if property is equal to the given value
  eq: String

  # Test if property is NOT equal to the given value
  ne: String

  # Test if property is less than or equal to the given value
  le: String

  # Test if property is less than the given value
  lt: String

  # Test if property is greater than or equal to the given value
  ge: String

  # Test if property is greater than the given value
  gt: String

  # Test if property begins with the given value.  Case-insensitive.
  beginsWith: String

  # Test if property ends with the given value.  Case-insensitive.
  endsWith: String

  # Test if property contains the given value.  Case-insensitive.
  contains: String

  # Test if property does not contain the given value.  Case-insensitive.
  notContains: String

  # Test if property is between the first 2 elements in the array
  between: [String!]

  # Test if property is equal to one of the given values
  in: [String]
}

# Generic integer filter criteria object, only one of these properties should be set
input IntFilterInput {
  # Test if property is equal to the given value
  eq: Int

  # Test if property is NOT equal to the given value
  ne: Int

  # Test if property is less than or equal to the given value
  le: Int

  # Test if property is less than the given value
  lt: Int

  # Test if property is greater than or equal to the given value
  ge: Int

  # Test if property is greater than the given value
  gt: Int

  # Test if property is between the first 2 elements in the array
  between: [Int!]

  # Test if property is equal to one of the given values
  in: [Int]
}

# Generic decimal number filter criteria object, only one of these properties should be set
input FloatFilterInput {
  # Test if property is equal to the given value
  eq: Float

  # Test if property is NOT equal to the given value
  ne: Float

  # Test if property is less than or equal to the given value
  le: Float

  # Test if property is less than the given value
  lt: Float

  # Test if property is greater than or equal to the given value
  ge: Float

  # Test if property is greater than the given value
  gt: Float

  # Test if property is between the first 2 elements in the array
  between: [Float!]

  # Test if property is equal to one of the given values
  in: [Float]
}

# Generic date filter criteria object, only one of these properties should be set
input DateFilterInput {
  # Test if property is equal to the given value
  eq: Date

  # Test if property is NOT equal to the given value
  ne: Date

  # Test if property is less than or equal to the given value
  le: Date

  # Test if property is less than the given value
  lt: Date

  # Test if property is greater than or equal to the given value
  ge: Date

  # Test if property is greater than the given value
  gt: Date

  # Test if property is between the first 2 elements in the array
  between: [Date!]
}

# Generic boolean filter criteria object, only one of these properties should be set
input BooleanFilterInput {
  # Test if property is equal to the given value
  eq: Boolean

  # Test if property is NOT equal to the given value
  ne: Boolean
}

type ErpInstitutionLocation {
  # Value that uniquely identifies the supplier site.
  locationId: Long!

  # Address Line 1
  addressLine1: ScmAddressLine

  # Address Line 2
  addressLine2: ScmAddressLine

  # Address Line 3
  addressLine3: ScmAddressLine

  # Address Line 4
  addressLine4: ScmAddressLine

  # City of the supplier address
  city: CityName

  # Postal code of the supplier address
  postalCode: ErpPostalCode

  # Country of the supplier address
  countryName: NonEmptyTrimmedString80

  # Abbreviation that identifies the country where the supplier address is located
  countryCode: ErpCountryCode

  # County of the supplier address
  county: NonEmptyTrimmedString60

  # State of the supplier address
  state: NonEmptyTrimmedString60
}

# Locations referenced by Supplier and AR Customer Sites
type ErpLocation {
  # Value that uniquely identifies the supplier site.
  locationId: Long!

  # Address Line 1
  addressLine1: ScmAddressLine

  # Address Line 2
  addressLine2: ScmAddressLine

  # Address Line 3
  addressLine3: ScmAddressLine

  # Address Line 4
  addressLine4: ScmAddressLine

  # City of the supplier address
  city: CityName

  # Postal code of the supplier address
  postalCode: ErpPostalCode

  # Country of the supplier address
  countryName: NonEmptyTrimmedString80

  # Abbreviation that identifies the country where the supplier address is located
  countryCode: ErpCountryCode

  # County of the supplier address
  county: NonEmptyTrimmedString60

  # State of the supplier address
  state: NonEmptyTrimmedString60
  statusCode: String!

  # The date from when the value is available for use.
  startDate: LocalDate

  # The date till which the value is available for use.
  endDate: LocalDate

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime!

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId
}

type ErpUnitOfMeasure {
  # Unique identifier of the Unit of Measure (UOM)
  unitOfMeasureId: Long

  # Unique short code assigned to a Unit of Measure (UOM)
  uomCode: ErpUnitOfMeasureCode

  # Translatable Unit of Measure (UOM) name
  name: NonEmptyTrimmedString25

  # Translatable Unit of Measure (UOM) description.
  description: NonEmptyTrimmedString50

  # Base Unit of Measure (UOM) flag.
  baseUOM: Boolean!
}

# Data object used to run searches on ErpUnitOfMeasure
input ErpUnitOfMeasureFilterInput {
  searchCommon: SearchCommonInputs
  name: StringFilterInput
  unitOfMeasureId: StringFilterInput
  uomCode: StringFilterInput
}

# Wrapper object for search results for ErpUnitOfMeasure
type ErpUnitOfMeasureSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ErpUnitOfMeasure!]!
}

# Represents one record per fusion system user
type ErpUser {
  # Mandatory Primary Key.
  id: Long!

  # The latest principal username of the user
  userId: NonEmptyTrimmedString100!

  # The description of the journal category associated with the row.
  personId: Long!

  # Person's First name.
  firstName: NonEmptyTrimmedString150!

  # Person's Last name.
  lastName: NonEmptyTrimmedString150!

  # Peron's Display name.
  displayName: NonEmptyTrimmedString360

  # Person's Full name.
  fullName: NonEmptyTrimmedString360

  # E-mail address.
  email: ErpEmailAddress

  # Unique code representing the status.
  assignmentStatus: NonEmptyTrimmedString30

  # Identifies the type of record: employee, CWK, applicant or non-workers
  assignmentType: NonEmptyTrimmedString30

  # Flag to mark when a user record that has been deleted in LDAP.
  active: Boolean

  # The date that the user is active from.
  startDate: Date

  # The date that the user ceases to be active in fusion.
  endDate: Date
  lastUpdateDateTime: Timestamp!
  lastUpdateUserId: ErpUserId
}

# Data object used to run searches on ErpUser
input ErpUserFilterInput {
  searchCommon: SearchCommonInputs
  id: StringFilterInput
  personId: StringFilterInput
  userId: StringFilterInput
  lastName: StringFilterInput
  displayName: StringFilterInput
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for ErpUser
type ErpUserSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ErpUser!]!
}

# Return type when requesting conversion of a KFS Account to the Oracle costing segments.
type KfsConvertAccountOutput {
  # Whether the account was found in the mapping table
  mappingFound: Boolean!

  # The chart code used when mapping.
  chart: KfsChartCode!

  # The account number used when mapping.
  account: KfsAccountNumber!

  # The sub account number used when mapping.  Will be undefined if no mapping using the sub account was found.
  subAccount: KfsSubAccountNumber

  # The type of cost center this maps to in Oracle.  Determines which of glSegments and ppmSegments are populated.
  costCenterType: ErpCostCenterType

  # If a GL cost center, the segments which could be derived from the given chart-account.
  glSegments: GlCostCenterSegments

  # If a POET cost center, the segments which could be derived from the given chart-account.
  ppmSegments: PpmCostCenterSegments
}

# The type of cost center needed by Oracle to record a transaction.
enum ErpCostCenterType {
  # General Ledger Segments: Transaction may be posted directly to the general ledger
  GL

  # POET Segments: Transaction belongs to a managed project and must be posted through the PPM sub-ledger.
  POET
}

# Cost-center components of Oracle GL Segments which can be derived from the KFS Chart-Account-Sub Account-Project.
type GlCostCenterSegments {
  entity: ErpEntityCode!
  fund: ErpFundCode!
  department: ErpDepartmentCode!
  purpose: ErpPurposeCode
  project: ErpProjectCode
  program: ErpProgramCode
  activity: ErpActivityCode
}

# Cost-center components of the POET Segments which can be derived from the KFS Chart-Account-Sub Account-Project.
type PpmCostCenterSegments {
  project: PpmProjectNumber!
  organization: PpmExpenseOrganizationCode!
  task: [PpmTaskNumber!]!
  award: PpmAwardNumber
  fundingSource: PpmFundingSourceNumber
}

# Return type when requesting conversion of a KFS Organization to the Oracle financial department.
type KfsConvertOrgOutput {
  # Whether the account was found in the mapping table
  mappingFound: Boolean!
  chart: KfsChartCode!
  org: KfsOrgCode!

  # The mapped financial department code.
  departmentCode: ErpDepartmentCode

  # The mapped department object if more information about the department is needed.
  department: ErpFinancialDepartment
}

# Represents an accounting period in the GL module of Oracle Financials.  Used for validation of submitted journal entry data.
type GlAccountingPeriod {
  # The unique name of a GL Accounting Period
  periodName: ErpAccountingPeriodName!
  periodYear: PositiveInt!
  periodNumber: PositiveInt!
  periodStatus: ErpPeriodStatus!
  adjustmentPeriod: Boolean!
  startDate: Date!
  endDate: Date!
  yearStartDate: Date!
  quarterStartDate: Date!
  quarterNumber: PositiveInt!
  effectivePeriodNumber: PositiveInt!
  lastUpdateDate: Timestamp!
  lastUpdateUserId: ErpUserId
}

# Valid values for an accounting period status.
enum ErpPeriodStatus {
  # Open
  O

  # Future Enterable
  F

  # Closed
  C

  # Permanently Closed
  P

  # Never Opened
  N
}

# Data object used to run searches on GlAccountingPeriod
input GlAccountingPeriodFilterInput {
  searchCommon: SearchCommonInputs
  periodName: StringFilterInput
  periodYear: IntFilterInput
  periodNumber: IntFilterInput
  periodStatus: StringFilterInput
  startDate: DateFilterInput
  endDate: DateFilterInput
  adjustmentPeriod: BooleanFilterInput
  lastUpdateDate: DateFilterInput
}

# Wrapper object for search results for GlAccountingPeriod
type GlAccountingPeriodSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [GlAccountingPeriod!]!
}

# GL/PPM Combined journal input type.  Contains the standard request header information and journal data payload for creating journal and/or PPM costs in Oracle Financials.
input GlJournalRequestInput {
  # Request-level header information common to all action requests.
  header: ActionRequestHeaderInput!

  # Main operation data.
  payload: GlJournalInput!
}

# Main payload object for a `glJournalRequest`.  See operation documentation for more info.
input GlJournalInput {
  # Centrally assigned source name for your boundary application.
  journalSourceName: NonEmptyTrimmedString80!

  # Centrally assigned category name for your boundary application's feed.
  journalCategoryName: NonEmptyTrimmedString80!

  # Name which will appear on the journal header.
  journalName: ErpNameField100!

  # Longer description of the journal if needed.
  journalDescription: ErpDescriptionField240

  # Reference number for the journal.  Should be meaningful to the feeding system.
  journalReference: GlReferenceField25!

  # Accounting Date: The accounting date of the journal.  Will be defaulted to today's date if not provided.
  accountingDate: LocalDate

  # Accounting Period: The accounting period of the journal.  If not specified, the API will add the current open period.
  accountingPeriodName: NonEmptyTrimmedString15

  # List of journal lines to include.
  journalLines: [GlJournalLineInput!]!
}

# A single line representing a GL Journal Entry or PPM Cost.  A line must have only one of the two types of segments specified.
#
# * `ppmSegments`, when provided will override any `glXxxxxx` segment values.
# * For the GL segments, there are three options.  Only provide one of them.  Providing multiple will result in a rejection of the payload.
input GlJournalLineInput {
  # GL Segment fields
  glSegments: GlSegmentInput

  # Delimited complete GL segment string.  All fields of the GL Accounting Key must be provided.
  glSegmentString: GlSegmentString

  # PPM POET segment values.  If provided, this will override any provided GL segments.
  ppmSegments: PpmSegmentInput

  # Hyphen-Delimited PPM segment string
  #
  # Must be populated with either the 4 required segments, or all 6 segments.  (Project-Task Number-Expense Organization-Expense Type-Award Number-Funding Source)
  #
  # * Format Pattern (Required Only): \`SP00000001-0001-0000000-000000\`
  # * Format Pattern (Sponsored Projects): \`CP00000001-0001-0000000-000000-0000000-00000\`
  #
  # For more information, see the description of the [PpmSegmentString scalar]({{Types.PpmSegmentString}})
  ppmSegmentString: PpmSegmentString

  # Debit amount of the GL transaction or PPM Cost.  Only one of debitAmount and creditAmount may be specified on a line.
  debitAmount: NonNegativeFloat

  # Credit amount of the GL transaction or PPM Cost.  Only one of debitAmount and creditAmount may be specified on a line.
  creditAmount: NonNegativeFloat

  # This 10-character field is intended to aid with linking boundary systems transactions to Oracle Cloud summarized journal entries for the purposes of reconciliation.
  externalSystemIdentifier: GlReferenceField10!

  # This 25-character field is intended to aid in additional linking of boundary systems transactions, as needed, to Oracle Cloud summarized journal entries for the purposes of reconciliation.
  externalSystemReference: GlReferenceField25

  # Expenditure comment for PPM transactions.  Will be ignored for GL transactions.
  ppmComment: GlDescriptionField40

  # GLIDe fields. These fields are optional.
  glide: GlideInput
}

# Output type for GLJournal requests and follow-up status updates.
#
# Contains the overall request status.  After a successful creation of the journal, will also contain the Oracle Financials assigned journal ID.
type GlJournalRequestStatusOutput {
  # Overall status of the action request
  requestStatus: ActionRequestStatus!

  # Results of the Job or Jobs required to submit this request to the ERP.
  processingResult: ProcessingResult

  # Errors found when validating the payload data.  These must be corrected before the request will be accepted.
  validationResults: ValidationResponse
}

# Return data structure when validating a set of GL segment values.
#
# The "result" property will contain the overall validation result and any error messages encountered during validation.  If any errors occur during data parsing (formats/required values), that will be returned as a GraphQL error per the specification in a top-level "errors" property.
#
# The operation will complete any missing segments with their defaults and return them populated in the "segments" property as well as the "completeChartstring" property.  Both of these are structured such that (if all properties requested) they could be included as accounting line or distribution data in other operations.
type GlValidateChartSegmentsOutput {
  # Validation result and error messages, if any.
  validationResponse: ValidationResponse!

  # Fully populated object with the GL segments combination that was validated.
  segments: GlSegments!

  # Full chartstring with the GL segments combination that was validated.
  completeChartstring: GlSegmentString

  # The "codeCombinationId" is an informational property only.  If populated, it
  # indicates that the validated combination of segment values was previously
  # known to the financial system.  Validity still needs to be checked, as
  # chartstrings can be disabled or expire.  However, segments which match an
  # existing valid combination can not fail validation when posted to the
  # financial system.
  codeCombinationId: Long
  segmentNames: GlSegmentNames!

  # Warnings, if any, related to segments validated during this operation.  The segmentName will be the same as the property name in the GlSegments object.
  warnings: [SegmentWarning!]

  # End Dates, if defined, after which a given segment will no longer be accepted for processing.  The segmentName will be the same as the property name in the GlSegments type.  Only segments which have defined end dates will be included in this list.
  endDates: [SegmentEndDate!]
}

# GLIDe fields are part of the GL/PPM Combined journal. These fields are optional.
input GlideInput {
  lineDescription: String
  journalLineNumber: Float
  transactionDate: Date
  udfNumeric1: Float
  udfNumeric2: Float
  udfNumeric3: Float
  udfDate1: Date
  udfDate2: Date
  udfString1: String
  udfString2: String
  udfString3: String
  udfString4: String
  udfString5: String
}

# The Award Number identifies the number assigned to an award containing funding activities.
#
# **Roll-up relationship to the new Chart of Accounts in the General Ledger:**
#
# * The Award Number value will NOT roll up to the Chart of Accounts. Award Number values will only be maintained in the PPM module.
#
# **Examples:**
#
# * Award Number values will be Oracle-generated
type PpmAward {
  # Award ID: Unique identifier of the award.
  id: Long!

  # Award Name: Name of the award.
  name: NonEmptyTrimmedString240

  #  Award Number: Award number tracked by the sponsor.
  awardNumber: NonEmptyTrimmedString30

  # The award type name associated with the award
  awardTypeName: String

  # Description: Brief description of the award.
  description: NonEmptyTrimmedString240

  # Start Date: Start date of the award.
  startDate: LocalDate

  # End Date: End date of the award.
  endDate: LocalDate

  # Close Date: Date past the end date of the award. Transactions for the award can be entered up to this date.
  closeDate: LocalDate

  # Award Owning Organization: An organization that owns awards within an enterprise. An organizing unit in the internal or external structure of your enterprise. Organization structures provide the framework for performing legal reporting, financial control, and management reporting for the award.
  awardOwningOrganizationName: String

  # Purpose: Name of the award purpose.
  awardPurpose: NonEmptyTrimmedString80

  # Type: Classification of an award, for example, Federal grants or Private grants.
  awardType: NonEmptyTrimmedString30

  # Business Unit: Unit of an enterprise that performs one or many business functions that can be rolled up in a management hierarchy. An award business unit is one within which the award is created.
  businessUnitName: NonEmptyTrimmedString100

  # The date when the award was last updated.
  lastUpdateDate: DateTime!

  # The user that last updated the award.
  lastUpdatedBy: ErpUserId

  # Award Funding Sources: The Award Funding Sources resource is used to view the attributes used to create or update a funding source for the award.
  awardFundingSource: [PpmFundingSource!]
  defaultFundingSourceNumber: PpmFundingSourceNumber

  # Returns whether this PpmAward is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the PpmAward must:
  # * Have closeDate after the given accountingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!
}

# Data object used to run searches on PpmAward
input PpmAwardFilterInput {
  searchCommon: SearchCommonInputs
  id: StringFilterInput
  name: StringFilterInput
  projectId: StringFilterInput
  awardType: StringFilterInput
  awardNumber: StringFilterInput
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for PpmAward
type PpmAwardSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [PpmAward!]!
}

# The Expenditure Type identifies the natural classification of the expense transaction being recorded.
#
# **Roll-up relationship to the Chart of Accounts in the General Ledger:**
#
# * The Expenditure Type value will roll up to the (Natural) Account segment in the Chart of Accounts.
# * The first 6 characters of the Expenditure Type value will correspond with the (Natural) Account value it rolls up to.
#
# **Examples:**
#
# * Salary
# * Fringe Benefits
# * Consulting Services
# * Travel
type PpmExpenditureType {
  # Expenditure Type ID: Unique identifier of the expenditure type.
  id: Long!

  # Expenditure Type: Name of the expenditure type.
  name: NonEmptyTrimmedString240!

  # Expenditure Type Code: The code of the Expenditure Type.
  code: String!

  # Expenditure Type Description: Description of the expenditure type.
  description: String

  # Expenditure Type Start Date: Start date of an expenditure type.
  startDate: LocalDate

  # Expenditure Type End Date: End date of an expenditure type.
  endDate: LocalDate

  # Expenditure Category: Name of the expenditure category.
  expenditureCategory: NonEmptyTrimmedString240

  # Revenue Category Code: Code of a category grouping of expenditure types by type of revenue.
  revenueCategoryCode: NonEmptyTrimmedString30

  # The date when the expenditure type was last updated.
  lastUpdateDateTime: DateTime!

  # The user that last updated the expenditure type.
  lastUpdatedBy: ErpUserId

  # Returns whether this PpmExpenditureType is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the PpmExpenditureType must:
  # * Have a startDate and endDate range which includes the given accoutingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!
}

# Data object used to run searches on PpmExpenditureType
input PpmExpenditureTypeFilterInput {
  searchCommon: SearchCommonInputs
  id: StringFilterInput
  name: StringFilterInput
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for PpmExpenditureType
type PpmExpenditureTypeSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [PpmExpenditureType!]!
}

# The Funding Source identifies the name of the sponsor for the external funding source.
#
# **Roll-up relationship to the new Chart of Accounts in the General Ledger:**
#
# * Funding Source values will only be used in the PPM module.
# * The Funding Source will map to the correct value for the Fund segment in the CoA
#   * (i.e In the examples below, NIH and USAID would map to the Federal Fund value in the Chart of Accounts)
#
# **Examples:**
#
# * National Institute of Health (NIH)
# * U.S. Agency for International Development (USAID)
type PpmFundingSource {
  # Funding Source ID: The unique identifier of the funding source.
  id: Long!

  # Funding Source Name: The source name of the funding source.
  name: NonEmptyTrimmedString360!

  # Funding Source Number: The number of the funding source.
  fundingSourceNumber: NonEmptyTrimmedString50!

  # Funding Source Description: The description of the funding source.
  description: NonEmptyTrimmedString240

  # Funding Source From Date: The date from which the funding source is active.
  fundingSourceFromDate: LocalDate!

  # Funding Source To Date: The date till which the funding source is active.
  fundingSourceToDate: LocalDate

  # The code of the funding source type.
  fundingSourceTypeCode: String

  # The date when the funding source was last updated.
  lastUpdateDateTime: DateTime!

  # The user that last updated the funding source.
  lastUpdatedBy: ErpUserId

  # The award id linked to the funding Source
  awardId: Long

  # Returns whether this PpmFundingSource is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the PpmFundingSource must:
  # * Have a fundingSourceFromDate and fundingSourceToDate range which includes the given accountingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!
}

# Data object used to run searches on PpmFundingSource
input PpmFundingSourceFilterInput {
  searchCommon: SearchCommonInputs
  fundingSourceNumber: StringFilterInput
  id: StringFilterInput
  name: StringFilterInput
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for PpmFundingSource
type PpmFundingSourceSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [PpmFundingSource!]!
}

# Cayuse support - non-segment data objects needed for submission of project and grant data
# Needed for to manage keywords for lookup table
type PpmKeywords {
  # ID: The unique identifier of the keyword.
  id: Long!

  # Keyword Name: The name of the keyword.
  name: NonEmptyTrimmedString150!

  # Keyword Description: The description for the Keyword.
  description: NonEmptyTrimmedString240

  # The date when the keyword was last updated.
  lastUpdateDateTime: DateTime!

  # The user that last updated the keyword.
  lastUpdatedBy: ErpUserId
}

# Data object used to run searches on PpmKeywords
input PpmKeywordsFilterInput {
  searchCommon: SearchCommonInputs
  name: StringFilterInput
  description: StringFilterInput
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for PpmKeywords
type PpmKeywordsSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [PpmKeywords!]!
}

# The Expenditure Organization identifies the organization that is incurring the expense and revenue. This may NOT be the same as the organization that owns the project.
#
# **Roll-up relationship to the new Chart of Accounts in the General Ledger:**
#
# * The Expenditure Organization value will roll up to the Financial Department segment of the Chart of Accounts.
#
# **Examples:**
#
# * Computer Science
# * Plant Sciences
type PpmOrganization {
  # Organization Code: The code of the Organization.
  code: String!

  # Organization Name: Name of the Organization
  name: NonEmptyTrimmedString100!

  # Effective Start Date: Start date of Organization
  effectiveStartDate: LocalDate!

  # Effective End Date: End date of Organization
  effectiveEndDate: LocalDate

  # Whether the expense organization allows costing transactions against it.
  enabled: Boolean!

  # Organization ID: Unique identifier of the Organization.  Internal to Oracle.
  id: Long!

  # Returns whether this PpmOrganization is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the PpmOrganization must:
  # * Have a effectiveStartDate and effectiveEndDate range which includes the given accountingDate
  # * Be enabled
  eligibleForUse(accountingDate: LocalDate): Boolean!
}

# Data object used to run searches on PpmOrganization
input PpmOrganizationFilterInput {
  searchCommon: SearchCommonInputs
  code: StringFilterInput
  name: StringFilterInput
  enabled: BooleanFilterInput
}

# Wrapper object for search results for PpmOrganization
type PpmOrganizationSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [PpmOrganization!]!
}

# The Project identifies the planned work or activity to be completed over a period of time and intended to achieve a particular goal.
#
# **Roll-up relationship to the new Chart of Accounts (CoA) in the General Ledger:**
#
# * The POET(AF) Project value will roll up to the Project segment of the Chart of Accounts.
# * PPM Project values and CoA Project segment values will be the same
#
# **Examples:**
#
# * Capital Projects
# * Sponsored Projects
# * Faculty Projects
type PpmProject {
  # Project ID: Unique identifier of the project.  Internal to Oracle.
  id: Long!

  # Project Number: Number of the project that is being created.  This will match the GL Project used to record costs to the ledger.
  projectNumber: PpmProjectNumber!

  # Project Name: Name of the project that is being created.
  name: NonEmptyTrimmedString240!

  # Project Description: A description about the project. This might include high-level information about the work being performed.
  description: String

  # Project Start Date: The date that work or information tracking begins on a project.
  projectStartDate: LocalDate!

  # Project Finish Date: The date that work or information tracking completes for a project.
  projectCompletionDate: LocalDate

  # Project Status: An implementation-defined classification of the status of a project. Typical project statuses are Active and Closed.
  projectStatus: NonEmptyTrimmedString80!

  # Project Status Code: The current status set on a project. A project status is an implementation-defined classification of the status of a project. Typical project status codes are ACTIVE and CLOSED.
  projectStatusCode: NonEmptyTrimmedString30!

  # Organization: An organizing unit in the internal or external structure of the enterprise. Organization structures provide the framework for performing legal reporting, financial control, and management reporting for the project.
  projectOrganizationName: NonEmptyTrimmedString240

  # Name of the component of the system that this project belongs to.  There is a separation between sponsored projects managed by CGA, and other managed projects.  The value in this field should align with the sponsoredProject flag.
  businessUnitName: NonEmptyTrimmedString240

  # Legal Entity: Name of the legal entity associated with the project. A legal entity is a recognized party with given rights and responsibilities by legislation. Legal entities generally have the right to own property, the right to trade, the responsibility to repay debt, and the responsibility to account for themselves to company regulators, taxation authorities, and owners according to rules specified in the relevant legislation.
  legalEntityName: NonEmptyTrimmedString240

  # Project Manager Email: Email of the person who leads the project team and who has the authority and responsibility for meeting the project objectives.
  primaryProjectManagerEmail: NonEmptyTrimmedString240

  # Project Manager: Name of the person who leads the project team and who has the authority and responsibility for meeting project objectives.
  primaryProjectManagerName: NonEmptyTrimmedString240

  # Source Application: The third-party application from which the project originates.
  sourceApplicationCode: NonEmptyTrimmedString30

  # Source Reference: The identifier of the project in the external system where it was originally entered.
  sourceProjectReference: NonEmptyTrimmedString30

  # TODO
  projectCategory: NonEmptyTrimmedString30

  # Sponsored Project Flag: Whether this project is a sponsored project and requires Award and Funding Source segments when assigning costs.
  sponsoredProject: Boolean!

  # Billing Enabled Flag: If billing is allowed for this project.
  billingEnabled: Boolean!

  # Capitalization Enabled Flag: If this is a capital project whose costs may need to be capitalized.
  capitalizationEnabled: Boolean!

  # Template Project Only Flag: If this project is a template for other projects.  Template projects may not have costs submitted against them.
  templateProject: Boolean!

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime!

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId

  # Tasks: The Task resource includes the attributes that are used to store values while creating or updating project tasks. Tasks are units of project work assigned or performed as part of the duties of a resource. Tasks can be a portion of project work to be performed within a defined period by a specific resource or multiple resources.
  #
  # By default, this will only list tasks which are allowed to be assigned costs.  If you need to see all tasks, set the property argument to false.
  tasks(
    # Whether to include only chargeable tasks in the results or all (including parent) tasks.
    chargeableOnly: Boolean = true
  ): [PpmTask!]
  awards: [PpmAward!]

  # For sponsored projects, the default award number that will be expensed if left off of the journal line or distribution.
  defaultAwardNumber: PpmAwardNumber

  # For sponsored projects, the default funding source that will be expensed if left off of the journal line or distribution.
  defaultFundingSourceNumber: PpmFundingSourceNumber

  # Returns whether this PpmProject is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the PpmProject must:
  # * Have a projectStatusCode of ACTIVE
  # * Not be a templateProject
  # * Have a projectStartDate and projectCompletionDate range which includes the given accountingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!
}

# Data object used to run searches on PpmProject
input PpmProjectFilterInput {
  searchCommon: SearchCommonInputs
  projectNumber: StringFilterInput
  name: StringFilterInput
  projectStartDate: DateFilterInput
  projectCompletionDate: DateFilterInput
  projectStatusCode: StringFilterInput
  primaryProjectManagerEmail: StringFilterInput
  sponsoredProject: BooleanFilterInput
  billingEnabled: BooleanFilterInput
  capitalizationEnabled: BooleanFilterInput
  templateProject: BooleanFilterInput
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for PpmProject
type PpmProjectSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [PpmProject!]!
}

# The Task identifies the activities used to further breakdown a PPM project. Every project MUST have at least one Task.  The number of tasks will vary by type of project.
#
# **Roll-up relationship to the new Chart of Accounts in the General Ledger:**
#
# * The Task value will NOT roll up to the Chart of Accounts. Task values will only be used in the PPM module.
# * Internal rules within the Oracle PPM module will be used to map the task to components of the GL Chart of Accounts which are not directly mapped to other components of the POET(AF) segments.
#
# **Examples:**
#
# * Design
# * Construction
# * Data Gathering & Analysis
type PpmTask {
  # Task ID: Unique identifier of the project task.
  id: Long!

  # Task Number: The number of a task.
  taskNumber: NonEmptyTrimmedString100!

  # Task Name: The name of the task. A task is a subdivision of the project work. Each project can have a set of top tasks and a hierarchy of subtasks below each top task.
  name: NonEmptyTrimmedString240!

  # Task Description: Text description of the project task that is being created.
  description: String

  # Task Start Date: Scheduled start date of the project task.
  taskStartDate: LocalDate

  # Task Finish Date: Scheduled end date of the project task.
  taskFinishDate: LocalDate

  # Billable: Indicates that transactions charged to that task can be billed to customers.
  billable: Boolean!

  # Chargeable: Indicates that something is eligible to be charged to a task.
  chargeable: Boolean!

  # Task Level: Indicates level of the task in the WBS.
  taskLevel: NonNegativeInt!

  # Display Sequence: The order in which the task is displayed in the project.
  executionDisplaySequence: NonNegativeInt!

  # Lowest Level Task: Indicates the task is at the lowest level.
  lowestLevelTask: Boolean!

  # Parent Task ID: Identifier of the parent task of the task.
  parentTaskId: Long

  # Top Task ID: Identifier of the top task to which the task rolls up. If the task is a top task, the identifier of the top task is same as the identifier of the task.
  topTaskId: Long

  # The date when the task was last updated.
  lastUpdateDateTime: DateTime!

  # The user that last updated the task.
  lastUpdatedBy: ErpUserId

  # The project that the task is linked to
  projectId: Long

  # Returns whether this PpmTask is valid to use on transactional documents for the given accounting date.  If not provided, the date will be defaulted to the current date.
  #
  # To be eligible for use, the PpmTask must:
  # * Be chargeable
  # * Be a lowestLevelTask
  # * Have a taskStartDate and taskFinishDate range which includes the given accountingDate
  eligibleForUse(accountingDate: LocalDate): Boolean!

  # GL Program used during subledger accounting jobs to post GL entries when costs are recorded against this task.
  glPostingProgramCode: ErpProgramCode

  # GL Purpose  used during subledger accounting jobs to post GL entries when costs are recorded against this task.
  glPostingPurposeCode: ErpPurposeCode

  # GL Fund used during subledger accounting jobs to post GL entries when costs are recorded against this task.
  glPostingFundCode: ErpFundCode

  # GL Activity used during subledger accounting jobs to post GL entries when costs are recorded against this task.
  glPostingActivityCode: ErpActivityCode
}

# Data object used to run searches on PpmTask
input PpmTaskFilterInput {
  searchCommon: SearchCommonInputs
  id: StringFilterInput
  name: StringFilterInput
  taskNumber: StringFilterInput
  chargeable: BooleanFilterInput
  billable: BooleanFilterInput
  lowestLevelTask: BooleanFilterInput
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for PpmTask
type PpmTaskSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [PpmTask!]!
}

# Cayuse support - non-segment data objects needed for submission of project and grant data
# Needed for to manage Terms and Conditions for lookup table
type PpmTerms {
  # ID: The unique identifier of the term.
  id: Long!

  # Term Name: The name of the Term.
  name: NonEmptyTrimmedString150!

  # Term Description: The description for the Term.
  description: NonEmptyTrimmedString240

  # Term start date: Start Date of the term
  startDate: LocalDate!

  # Term end date: End Date of the term
  endDate: LocalDate

  # Category Name: The category name of the Term
  categoryName: NonEmptyTrimmedString150!

  # Category Description: The category description of the Term
  categoryDescription: NonEmptyTrimmedString240

  # The date when the keyword was last updated.
  lastUpdateDateTime: DateTime

  # The user that last updated the term.
  lastUpdatedBy: ErpUserId
}

# Data object used to run searches on PpmTerms
input PpmTermsFilterInput {
  searchCommon: SearchCommonInputs
  name: StringFilterInput
  description: StringFilterInput
  categoryName: StringFilterInput
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for PpmTerms
type PpmTermsSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [PpmTerms!]!
}

# Return data structure when validating a set of PPM segment values.
#
# The "result" property will contain the overall validation result and any error messages encountered during validation.  If any errors occur during data parsing (formats/required values), that will be returned as a GraphQL error per the specification in a top-level "errors" property.
#
# The operation will complete any missing segments with their defaults and return them populated in the "segments" property.  This property is structured such that they could be included as accounting line or distribution data in other operations.
type PpmSegmentsValidateOutput {
  # Validation result and error messages, if any.
  validationResponse: ValidationResponse!

  # Fully populated object with the PPM segments combination that was validated.
  segments: PpmSegments!

  # PPM segment string matching the segments object.  Only populated if the validation passes.
  segmentString: PpmSegmentString
}

# Nature of the payment for this one.  In general, all lines should be ITEM.
enum ScmLineType {
  ITEM
  FREIGHT
  MISCELLANEOUS
}

# Nature of the invoice when paying one for a PO.  This would drive the natural account.  Use STANDARD unless directed otherwise.
enum ScmInvoiceType {
  STANDARD
  PREPAYMENT
  CREDIT
  DEBIT
}

# Invoice Lines attributes for ScmInvoicePayment.
input ScmInvoiceLineInput {
  # The inventory item name.
  itemName: NonEmptyTrimmedString255!

  # The description of the item in the invoice line. The default value is populated from the inventory item.
  itemDescription: String!

  # The line amount in invoice currency. The value must be provided while creating an invoice line.
  lineAmount: Float!

  # The type of invoice line. The value must be provided while creating an invoice line. The valid values are Item, Freight and Miscellaneous. A list of accepted values is defined in the lookup type INVOICE LINE TYPE and can be reviewed using the Setup and Maintenance work area, and the Manage Payables Lookups task.
  lineType: ScmLineType!

  # The purchase order line number that is matched to the invoice line.
  purchaseOrderLineNumber: PositiveInt

  # The unique identifier for the item category.
  purchasingCategory: NonEmptyTrimmedString250

  # The quantity of items invoiced include matched invoice lines, price corrections, quantity corrections, and unmatched invoice lines.
  quantity: PositiveInt!

  # The unit of measure for the quantity invoiced.
  unitOfMeasure: NonEmptyTrimmedString25!

  # The price charged per unit of a good or service.
  unitPrice: Float!
  glSegments: GlSegmentInput

  # Delimited complete GL segment string.  All fields of the GL Accounting Key must be provided.
  glSegmentString: GlSegmentString

  # PPM POET segment values.  If provided, this will override any provided or default GL segments.
  ppmSegments: PpmSegmentInput
}

# AP Invoice Payment input type.  Contains the standard request header information and invoice data payload for Oracle Financials.
input ScmInvoicePaymentRequestInput {
  # Request-level header information common to all action requests.
  header: ActionRequestHeaderInput!

  # ScmInvoicePayment data
  payload: ScmInvoicePaymentInput!
}

# Main payload object for a `scmInvoicePaymentCreate` operation.  See operation documentation for more info.
input ScmInvoicePaymentInput {
  # The date when the payment is to be accounted.
  accountingDate: LocalDate

  # Indicates the business unit name for the invoice.
  businessUnit: NonEmptyTrimmedString240!

  # The statement that describes the invoice.
  invoiceDescription: NonEmptyTrimmedString240!

  # The invoice amount in transaction currency. The value must be provided while creating an invoice.
  invoiceAmount: Float!

  # The date on the supplier invoice. The value can either be provided while creating an invoice or populated by default to the system date.
  invoiceDate: LocalDate

  # The unique number for supplier invoice.
  invoiceNumber: NonEmptyTrimmedString50!

  # Code that indicates the feeder system from which an invoice is created.
  invoiceSourceCode: NonEmptyTrimmedString25!

  # The type of the invoice. The valid invoice types are Standard, Prepayment, Credit Memo, Debit Memo.
  invoiceType: ScmInvoiceType!

  # The user-entered payment method code that helps to uniquely identify a payment method.
  paymentMethodCode: NonEmptyTrimmedString30

  # The payment terms used to calculate installments and to calculate due dates, discount dates, and discount amounts for each invoice.
  paymentTerms: NonEmptyTrimmedString50

  # The purchase order document number that is matched to the invoice.
  purchaseOrderNumber: NonEmptyTrimmedString30

  # The unique number to identify the supplier.
  supplierNumber: NonEmptyTrimmedString30!

  # The name of the physical location of the supplier from where the goods and services are rendered.
  supplierSiteCode: NonEmptyTrimmedString15!

  # The payables invoice lines resource is used to manage details about goods and services, which includes freight, and miscellaneous charges that can be allocated to item lines.
  invoiceLines: [ScmInvoiceLineInput!]!
}

# Output type for ScmInvoicePayment requests and follow-up status updates.
#
# Contains the overall request status.  After a successful creation of the payment, will contain the Oracle Financials assigned ID.
type ScmInvoicePaymentRequestStatusOutput {
  # Status of the action request overall.
  requestStatus: ActionRequestStatus!

  # Validation errors of payload data
  validationResults: ValidationResponse
}

type ScmPaymentTerm {
  termId: Long!
  name: NonEmptyTrimmedString50!
  description: NonEmptyTrimmedString240!

  # The date from when the value is available for use.
  startDateActive: Date

  # The date till which the value is available for use.
  endDateActive: Date

  # Indicates that the Payment Term is enabled.
  enabled: Boolean!

  # Specifies the type of payment terms.
  termType: NonEmptyTrimmedString15

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime!

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId
}

# Data object used to run searches on ScmPaymentTerm
input ScmPaymentTermFilterInput {
  searchCommon: SearchCommonInputs
  name: StringFilterInput
  enabled: BooleanFilterInput
  lastUpdateDateTime: DateFilterInput
}

# Wrapper object for search results for ScmPaymentTerm
type ScmPaymentTermSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ScmPaymentTerm!]!
}

# scm Purchase Requisition input type.  Contains the standard request header information and requisition data payload for creating requisition in Oracle Financials.
input ScmPurchaseRequisitionRequestInput {
  # Request-level header information common to all action requests.
  header: ActionRequestHeaderInput!

  # ScmInvoicePayment data
  payload: ScmPurchaseRequisitionInput!
}

# Main payload object for a `scmPurchaseRequisitionRequest`.  See operation documentation for more info.
input ScmPurchaseRequisitionInput {
  # Centrally assigned source name for your boundary application.
  requisitionSourceName: NonEmptyTrimmedString50!

  # Centrally assigned category name for your boundary application's feed.
  requisitionCategoryName: NonEmptyTrimmedString80!
  supplierNumber: NonEmptyTrimmedString30!
  requesterUserId: String!

  # Value that uniquely identifies the supplier site.
  supplierSiteCode: String!

  # Description of the requisition
  description: NonEmptyTrimmedString240!

  # Reason for creating the requisition. Max Length:1000
  justification: NonEmptyTrimmedString1000!
  transactionDate: LocalDate
  lines: [ScmPurchaseRequisitionLineInput!]!
}

# A single line representing a Requisition Line Item.  A line must have only one of the two types of segments specified.
input ScmPurchaseRequisitionLineInput {
  # Total amount of the requested items in the currency of the buying company.
  amount: NonNegativeFloat!

  # Quantity of the goods being purchased.
  quantity: NonNegativeFloat!

  # The unit of measure for the quantity invoiced.
  unitOfMeasure: NonEmptyTrimmedString25!

  # Description of the goods or services being purchased.
  itemDescription: NonEmptyTrimmedString240!

  # Note to the buyer who will be processing the request.
  noteToBuyer: NonEmptyTrimmedString1000

  # Name of the purchasing category that is used for classifying the purchase being made by using this order line. MaxLine:2400
  purchasingCategoryName: String!

  # Price of the requested item in the currency of the buying company.
  unitPrice: NonNegativeFloat!
  deliverToTypeCode: String

  # Abbreviation that identifies the final location where the buying company should deliver the goods previously received from a supplier.
  deliveryToLocationCode: NonEmptyTrimmedString60
  requestedDeliveryDate: LocalDate
  distributions: [ScmPurchaseRequisitionDistributionInput!]!
}

# A single line representing a GL Journal Entry or PPM Cost.  A line must have only one of the two types of expense location specified.
input ScmPurchaseRequisitionDistributionInput {
  amount: NonNegativeFloat
  percent: NonNegativeFloat
  quantity: NonNegativeFloat
  glSegments: GlSegmentInput

  # Delimited complete GL segment string.  All fields of the GL Accounting Key must be provided.
  glSegmentString: GlSegmentString

  # PPM POET segment values.  If provided, this will override any provided or default GL segments.
  ppmSegments: PpmSegmentInput

  # PPM POET segment values.  If provided, this will override any provided or default GL segments.
  ppmSegmentString: PpmSegmentString
}

# Output type for ScmPurchaseRequisition creation and follow-up status updates.
#
# Contains the overall request status.  After a successful creation of the document, will also contain the Oracle Financials assigned ID.
type ScmPurchaseRequisitionRequestStatusOutput {
  # Status of the action request overall.
  requestStatus: ActionRequestStatus!

  # Validation errors of payload data
  validationResults: ValidationResponse
}

# The SCM purchasing category represent the type of item being paid for on an invoice payment.
#
# The Oracle Purchasing category is the conceptual replacement for the KFS Commodity Code.
type ScmPurchasingCategory {
  # Unique identifier of the Category Code
  categoryId: Long!

  # A category is used to manage the catalog hierarchy. Items are assigned to categories in the catalog.
  categoryCode: String!

  # Category Content Code.
  categoryContentCode: String

  # The date from when the value is available for use.
  startDateActive: Date

  # The date till which the value is available for use.
  endDateActive: Date

  # Indicates that the Category is enabled.
  enabled: Boolean!

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime!

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId
}

# Data object used to run searches on ScmPurchasingCategory
input ScmPurchasingCategoryFilterInput {
  searchCommon: SearchCommonInputs
  categoryCode: StringFilterInput
  categoryId: StringFilterInput
}

# Wrapper object for search results for ScmPurchasingCategory
type ScmPurchasingCategorySearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ScmPurchasingCategory!]!
}

# A defined supplier of goods or services in the ERP system.
#
# Each supplier may have multiple sites at which they do business.  It is necessary to identify both the supplier and site when submitting a payment.
#
# Supplier in Oracle replaces Vendor in KFS.
type ScmSupplier {
  # Value that uniquely identifies the supplier internally to Oracle.
  supplierId: Long!

  # Unique ID for the supplier used to reference it within the UI and in interfaces.  This largely corresponds to the Vendor ID in KFS.
  supplierNumber: Long!

  # Supplier: Name of the supplier.
  name: NonEmptyTrimmedString360!

  # Alias: Alternate internal name for used for the supplier.
  aliasName: NonEmptyTrimmedString360

  # Alternate Name: Alternate name of the supplier.
  alternateName: NonEmptyTrimmedString360

  # Business Relationship: Business relationship between the enterprise and the supplier.
  businessRelationshipCode: NonEmptyTrimmedString30

  # Supplier Type: Type of supplier.
  supplierType: NonEmptyTrimmedString80

  # The date from when the value is available for use.
  startDateActive: Date

  # The date till which the value is available for use.
  endDateActive: Date

  # Timestamp this record was last updated in the financial system.
  lastUpdateDateTime: DateTime!

  # User ID of the person who last updated this record.
  lastUpdateUserId: ErpUserId

  # Supplier business locations referenced when making orders or payments to the supplier.
  sites: [ScmSupplierSite!]!
}

# Supplier Site represents a business location referenced when making orders or payments to the supplier.
type ScmSupplierSite {
  # Value that uniquely identifies the supplier site internally within Oracle.
  supplierSiteId: Long!

  # Code used to identify the site on the UI and in interfaces.
  supplierSiteCode: NonEmptyTrimmedString15!

  # Internal location code containing address information.
  locationId: Long

  # Physical address of the site.
  location: ErpLocation
}

# Input object used to run searches on ScmSupplier
input ScmSupplierFilterInput {
  searchCommon: SearchCommonInputs
  name: StringFilterInput
  aliasName: StringFilterInput
  alternateName: StringFilterInput
  supplierId: StringFilterInput
  supplierNumber: StringFilterInput
  lastUpdateDateTime: DateFilterInput
}

# Search results object for ScmSupplier
type ScmSupplierSearchResults {
  # Information about the search results returned.
  metadata: SearchResultMetadata!

  # Results of the search
  data: [ScmSupplier!]!
}

# Contains information about the ERP API server's version.
type ErpApiInfo {
  versionNumber: String!
  shortHash: String
  branch: String
  committedOn: Date
  erpSchema: String!
  apiSchema: String!
}

type Query {
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!

  # Get a single ApAccountingPeriod by its name.  Returns undefined if does not exist
  apAccountingPeriod(periodName: String!): ApAccountingPeriod

  # Get a single non-adjustment ApAccountingPeriod by the given date.  Returns undefined if no period is defined for the given date.
  apAccountingPeriodByDate(accountingDate: Date!): ApAccountingPeriod

  # Search for ApAccountingPeriod objects by multiple properties.
  # See
  # See the ApAccountingPeriodFilterInput type for options.
  apAccountingPeriodSearch(
    filter: ApAccountingPeriodFilterInput!
  ): ApAccountingPeriodSearchResults!

  # Get a single ArAccountingPeriod by its name.  Returns undefined if does not exist
  arAccountingPeriod(periodName: String!): ArAccountingPeriod

  # Get a single non-adjustment ArAccountingPeriod by the given date.  Returns undefined if no period is defined for the given date.
  arAccountingPeriodByDate(accountingDate: Date!): ArAccountingPeriod

  # Search for ArAccountingPeriod objects by multiple properties.
  # See
  # See the ArAccountingPeriodFilterInput type for options.
  arAccountingPeriodSearch(
    filter: ArAccountingPeriodFilterInput!
  ): ArAccountingPeriodSearchResults!

  # Get a single ArCustomerAccount by accountNumber.  Returns undefined if does not exist
  arCustomerAccount(accountNumber: String!): ArCustomerAccount

  # Get a single ArCustomerAccount by accountName.  Returns undefined if does not exist
  arCustomerAccountByAccountName(accountName: String!): ArCustomerAccount

  # Search for ArCustomerAccount objects by multiple properties.
  # See the ArCustomerAccountFilterInput type for options.
  arCustomerAccountSearch(
    filter: ArCustomerAccountFilterInput!
  ): ArCustomerAccountSearchResults!

  # Get the status of a previously submitted AR invoice request by the API-assigned request ID.
  arInvoiceRequestStatus(requestId: String!): ArInvoiceRequestStatusOutput

  # Get the status of a previously submitted AR invoice request by the consumer's unique tracking ID.
  arInvoiceRequestStatusByConsumerTracking(
    consumerTrackingId: String!
  ): ArInvoiceRequestStatusOutput

  # Get the statuses of previously submitted AR invoice requests by the consumer's reference ID.
  arInvoiceRequestStatusByConsumerReference(
    consumerReferenceId: String!
  ): [ArInvoiceRequestStatusOutput!]!

  # Using the provided transaction number, check on the status of the given invoice.  Returns null if the transaction number is unknown.
  arInvoiceSummary(transactionNumber: String!): ArInvoiceSummary

  # Get a single ArMemoLine by id.  Returns undefined if does not exist
  arMemoLine(id: String!): ArMemoLine

  # Get a single ArMemoLine by name.  Returns undefined if does not exist
  arMemoLineByName(name: String!): ArMemoLine

  # Search for ArMemoLine objects by multiple properties.
  # See the ArMemoLineFilterInput type for options.
  arMemoLineSearch(filter: ArMemoLineFilterInput!): ArMemoLineSearchResults!

  # Get a single ArPaymentTerm by code.  Returns undefined if does not exist
  arPaymentTerm(id: Long!): ArPaymentTerm

  # Get a single ArPaymentTerm by name.  Returns undefined if does not exist
  arPaymentTermByName(name: NonEmptyTrimmedString15!): ArPaymentTerm

  # Search for ArPaymentTerm objects by multiple properties.
  # See
  # See the ArPaymentTermFilterInput type for options.
  arPaymentTermSearch(
    filter: ArPaymentTermFilterInput!
  ): ArPaymentTermSearchResults!

  # Get a single ErpAccount by code.  Returns undefined if does not exist
  erpAccount(code: String!): ErpAccount

  # Get all currently valid ErpAccount objects.
  erpAccountAll(sort: [String!]): [ErpAccount!]!

  # Get items under the given ErpAccount in the hierarchy.
  # Returns undefined if the parent does not exist.
  # Returns an empty list if the given record has no children.
  erpAccountChildren(code: String!): [ErpAccount!]

  # Search for ErpAccount objects by multiple properties.
  # See the ErpAccountFilterInput type for options.
  erpAccountSearch(filter: ErpAccountFilterInput!): ErpAccountSearchResults!

  # Get a single ErpActivity by code.  Returns undefined if does not exist
  erpActivity(code: String!): ErpActivity

  # Get items under the given ErpActivity in the hierarchy.
  # Returns undefined if the parent does not exist.
  # Returns an empty list if the given record has no children.
  erpActivityChildren(code: String!): [ErpActivity!]

  # Search for ErpActivity objects by multiple properties.
  # See the ErpActivityFilterInput type for options.
  erpActivitySearch(filter: ErpActivityFilterInput!): ErpActivitySearchResults!

  # Get a single ErpEntity by code.  Returns undefined if does not exist
  erpEntity(code: String!): ErpEntity

  # Get all currently valid ErpEntity objects.
  erpEntityAll(sort: [String!]): [ErpEntity!]!

  # Get items under the given ErpEntity in the hierarchy.
  # Returns undefined if the parent does not exist.
  # Returns an empty list if the given record has no children.
  erpEntityChildren(code: String!): [ErpEntity!]

  # Search for ErpEntity objects by multiple properties.
  # See
  # See the ErpEntityFilterInput type for options.
  erpEntitySearch(filter: ErpEntityFilterInput!): ErpEntitySearchResults!

  # Get a single ErpFinancialDepartment by code.  Returns undefined if does not exist.
  erpFinancialDepartment(code: String!): ErpFinancialDepartment

  # Get all currently enabled ErpFinancialDepartment objects.
  erpFinancialDepartmentAll(sort: [String!]): [ErpFinancialDepartment!]!

  # Get items under the given ErpFinancialDepartment in the segment hierarchy.
  # Returns undefined if the parent does not exist.
  # Returns an empty list if the given record has no children.
  erpFinancialDepartmentChildren(
    # The code of the parent.
    code: String!
  ): [ErpFinancialDepartment!]

  # Search for ErpFinancialDepartment objects by multiple properties.
  # See
  # See the ErpFinancialDepartmentFilterInput type for options.
  erpFinancialDepartmentSearch(
    filter: ErpFinancialDepartmentFilterInput!
  ): ErpFinancialDepartmentSearchResults!

  # Get a single ErpFund by code.  Returns undefined if does not exist
  erpFund(code: String!): ErpFund

  # Get items under the given ErpFund in the hierarchy.
  # Returns undefined if the parent does not exist.
  # Returns an empty list if the given record has no children.
  erpFundChildren(code: String!): [ErpFund!]

  # Search for ErpFund objects by multiple properties.
  # See
  # See the ErpFundFilterInput type for options.
  erpFundSearch(filter: ErpFundFilterInput!): ErpFundSearchResults!

  # Get a single ErpProgram by code.  Returns undefined if does not exist
  erpProgram(code: String!): ErpProgram

  # Get items under the given ErpProgram in the hierarchy.
  # Returns undefined if the parent does not exist.
  # Returns an empty list if the given record has no children.
  erpProgramChildren(code: String!): [ErpProgram!]

  # Search for ErpProgram objects by multiple properties.
  # See
  # See the ErpProgramFilterInput type for options.
  erpProgramSearch(filter: ErpProgramFilterInput!): ErpProgramSearchResults!

  # Get a single ErpProject by code.  Returns undefined if does not exist
  erpProject(code: String!): ErpProject

  # Get items under the given ErpProject in the hierarchy.
  # Returns undefined if the parent does not exist.
  # Returns an empty list if the given record has no children.
  erpProjectChildren(code: String!): [ErpProject!]

  # Search for ErpProject objects by multiple properties.
  # See the ErpProjectFilterInput type for options.
  erpProjectSearch(filter: ErpProjectFilterInput!): ErpProjectSearchResults!

  # Get a single ErpPurpose by code.  Returns undefined if does not exist
  erpPurpose(code: String!): ErpPurpose

  # Get all currently valid ErpPurpose objects.
  erpPurposeAll(sort: [String!]): [ErpPurpose!]!

  # Get items under the given ErpPurpose in the hierarchy.
  # Returns undefined if the parent does not exist.
  # Returns an empty list if the given record has no children.
  erpPurposeChildren(code: String!): [ErpPurpose!]

  # Search for ErpPurpose objects by multiple properties.
  # See
  # See the ErpPurposeFilterInput type for options.
  erpPurposeSearch(filter: ErpPurposeFilterInput!): ErpPurposeSearchResults!

  # Get a single ErpUnitOfMeasure by unitOfMeasureId.  Returns undefined if does not exist
  erpUnitOfMeasure(unitOfMeasureId: String!): ErpUnitOfMeasure

  # Get a single ErpUnitOfMeasure by uom code.  Returns undefined if does not exist
  erpUnitOfMeasureByCode(uomCode: String!): ErpUnitOfMeasure

  # Get a single ErpUnitOfMeasure by unit of measure.  Returns undefined if does not exist
  erpUnitOfMeasureByName(name: String!): ErpUnitOfMeasure

  # Search for ErpUnitOfMeasure objects by multiple properties.
  # See the ErpUnitOfMeasureFilterInput type for options.
  erpUnitOfMeasureSearch(
    filter: ErpUnitOfMeasureFilterInput!
  ): ErpUnitOfMeasureSearchResults!

  # Get a single ErpUser by id.  Returns undefined if does not exist
  erpUser(id: String!): ErpUser

  # Get a single ErpUser by user id.  Returns undefined if does not exist
  erpUserByUserId(userId: String!): ErpUser

  # Get all currently valid ErpUser objects.
  erpUserAll(sort: [String!]): [ErpUser!]!

  # Search for ErpUser objects by multiple properties.
  # See
  # See the ErpUserFilterInput type for options.
  erpUserSearch(filter: ErpUserFilterInput!): ErpUserSearchResults!

  # Accepts a chart and account (and optionally a sub account and/or project code) which was converted as part of cutover and returns the cost center portion with matching GL or POET segments needed to record a transaction.  If no match is found when a sub account or project code is provided, the conversion will revert to only using the chart and account.  The attributes used for the returned converted values will be included in the response.
  #
  # In the case of a POET segment response, an array of tasks will be returned.  The data conversion mapping does not contain that information.  At cutover, there will be only one task per project.  However, additional tasks will be added as part of use after go-live.
  kfsConvertAccount(
    chart: KfsChartCode!
    account: KfsAccountNumber!
    subAccount: KfsSubAccountNumber
  ): KfsConvertAccountOutput!

  # Accepts a chart and org code which was converted as part of cutover and returns the financial department(s) to which it was mapped.
  kfsConvertOrgCode(
    chart: KfsChartCode!
    org: KfsOrgCode!
  ): KfsConvertOrgOutput!

  # Get a single GlAccountingPeriod by its name.  Returns undefined if does not exist
  glAccountingPeriod(periodName: String!): GlAccountingPeriod

  # Get a single non-adjustment GlAccountingPeriod by the given date.  Returns undefined if no period is defined for the given date.
  glAccountingPeriodByDate(accountingDate: Date!): GlAccountingPeriod

  # Search for GlAccountingPeriod objects by multiple properties.
  # See
  # See the GlAccountingPeriodFilterInput type for options.
  glAccountingPeriodSearch(
    filter: GlAccountingPeriodFilterInput!
  ): GlAccountingPeriodSearchResults!

  # Get the status of a previously submitted journal voucher request by the API-assigned request ID.
  glJournalRequestStatus(requestId: String!): GlJournalRequestStatusOutput

  # Get the status of a previously submitted journal voucher request by the consumer's unique tracking ID.
  glJournalRequestStatusByConsumerTracking(
    consumerTrackingId: String!
  ): GlJournalRequestStatusOutput

  # Get the statuses of previously submitted journal voucher requests by the consumer's reference ID.
  glJournalRequestStatusByConsumerReference(
    consumerReferenceId: String!
  ): [GlJournalRequestStatusOutput!]!

  # Validates that the given set of GL chartstring segments are most likely valid for posting
  # to the financial system general ledger.  Individual non-blank elements will be checked
  # for current validity.
  #
  # If validateCVRs is true, certain combinations of attributes will be sanity checked.
  #
  # This operation will return a fully populated set of segments, including defaults in
  # both individual segment and full chartstring form.
  #
  # If the combination was previously known/used in the financial system, its unique ID will be included.
  glValidateChartSegments(
    segments: GlSegmentInput!
    validateCVRs: Boolean
  ): GlValidateChartSegmentsOutput!

  # Validates that the given GL chartstring is most likely valid for posting
  # to the financial system general ledger.  The input string format is strongly typed
  # and will reject the call if not structured properly.  Please see the definition of the
  # [GlSegmentString]({{Types.GlSegmentString}}) for format information.
  #
  # If validateCVRs is true, certain combinations of attributes will be sanity checked if the string format is accepted.
  #
  # This operation will return the validation result and the segments as parsed out into their component fields.
  #
  # If the combination was previously known/used in the financial system, its unique ID will be included.
  glValidateChartstring(
    segmentString: GlSegmentString!
    validateCVRs: Boolean
  ): GlValidateChartSegmentsOutput!

  # Get a single PpmAward by id.  Returns undefined if does not exist
  ppmAward(id: String!): PpmAward

  # Gets PpmAwards by exact name.  Returns empty list if none are found
  ppmAwardByName(name: String!): [PpmAward!]!

  # Gets PpmAwards by project.  Returns empty  if not found
  ppmAwardByProjectId(projectId: String!): [PpmAward!]!

  # Gets undefineds by number.  Returns empty if not found
  ppmAwardByNumber(number: String!): PpmAward

  # Gets undefineds by projectNumber and awardNumber.  Returns null if not found
  ppmAwardByProjectAndAwardNumber(
    projectNumber: String!
    awardNumber: String!
  ): PpmAward

  # Search for PpmAward objects by multiple properties.
  # See
  # See the PpmAwardFilterInput type for options.
  ppmAwardSearch(filter: PpmAwardFilterInput!): PpmAwardSearchResults!

  # Get a single PpmExpenditureType by id.  Returns undefined if does not exist.
  #
  # This ID is an internal tracking number used by the financial system.  It is only used to link between objects internally.
  # Use the ppmExpenditureTypeByName or ppmExpenditureTypeByAccount operations to pull by a unique identifier.
  ppmExpenditureType(id: String!): PpmExpenditureType

  # Gets PpmExpenditureTypes by exact name.  Returns empty list if none are found
  ppmExpenditureTypeByName(name: NonEmptyTrimmedString100!): PpmExpenditureType!

  # Get a single PpmExpenditureType by code.  Returns undefined if does not exist
  ppmExpenditureTypeByCode(code: String!): PpmExpenditureType

  # Gets PpmExpenditureTypes by the associated GL Account.  Returns undefined if none is found.
  #
  # PPM Expense Type names will be the GL Account number plus a description.  This full string must be used in file-based feeds.
  # This method will allow you to obtain the exact string (in the name property) that needs to be included.
  ppmExpenditureTypeByAccount(account: ErpAccountCode!): PpmExpenditureType

  # Search for PpmExpenditureType objects by multiple properties.
  # See
  # See the PpmExpenditureTypeFilterInput type for options.
  ppmExpenditureTypeSearch(
    filter: PpmExpenditureTypeFilterInput!
  ): PpmExpenditureTypeSearchResults!

  # Get a single PpmFundingSource by id.  Returns undefined if does not exist
  ppmFundingSource(id: String!): PpmFundingSource

  # Get a single PpmFundingSource by number.  Returns undefined if does not exist
  ppmFundingSourceByNumber(fundingSourceNumber: String!): PpmFundingSource

  # Get a single PpmFundingSource by project number and funding source number.  Returns null if does not exist
  ppmFundingSourceByProjectAndFundingSourceNumber(
    projectNumber: String!
    fundingSourceNumber: String!
  ): PpmFundingSource

  # Gets PpmFundingSources by exact name.  Returns empty list if none are found
  ppmFundingSourceByName(name: String!): [PpmFundingSource!]!

  # Search for PpmFundingSource objects by multiple properties.
  # See
  # See the PpmFundingSourceFilterInput type for options.
  ppmFundingSourceSearch(
    filter: PpmFundingSourceFilterInput!
  ): PpmFundingSourceSearchResults!

  # Get a single PpmKeywords by id.  Returns undefined if does not exist
  ppmKeywords(id: String!): PpmKeywords

  # Gets PpmKeywordss by exact name.  Returns empty list if none are found
  ppmKeywordsByName(name: String!): [PpmKeywords!]!

  # Search for PpmKeywords objects by multiple properties.
  # See
  # See the PpmKeywordsFilterInput type for options.
  ppmKeywordsSearch(filter: PpmKeywordsFilterInput!): PpmKeywordsSearchResults!

  # Get a single PpmOrganization by code.  Returns undefined if does not exist
  ppmOrganization(code: String!): PpmOrganization

  # Gets PpmOrganizations by exact name.  Returns undefined if does not exist
  ppmOrganizationByName(name: String!): PpmOrganization

  # Search for PpmOrganization objects by multiple properties.
  # See
  # See the PpmOrganizationFilterInput type for options.
  ppmOrganizationSearch(
    filter: PpmOrganizationFilterInput!
  ): PpmOrganizationSearchResults!

  # Get a single PpmProject by code.  Returns undefined if does not exist
  ppmProject(projectId: String!): PpmProject

  # Get a single PpmProject by the project number.  Returns undefined if no project with that number is found.
  ppmProjectByNumber(projectNumber: String!): PpmProject

  # Gets a list of PpmProjects by exact name.  Returns empty list if none are found.  Project Name should be unique in oracle.
  ppmProjectByName(projectName: String!): [PpmProject!]!

  # Gets default award and funding source for PpmProjects by exact name.   Project Name should be unique in oracle.
  ppmProjectDefaultAwardFundingSource(projectName: String!): [PpmProject!]!

  # Search for PpmProject objects by multiple properties.
  # See
  # See the PpmProjectFilterInput type for options.
  ppmProjectSearch(filter: PpmProjectFilterInput!): PpmProjectSearchResults!

  # Get a single PpmTask by id.  Returns undefined if it does not exist
  ppmTask(id: String!): PpmTask

  # Get a single PpmTask by number.  Returns undefined if does not exist
  ppmTaskByNumber(taskNumber: String!): PpmTask

  # Gets PpmTasks by exact name.  Returns empty list if none are found
  ppmTaskByName(name: NonEmptyTrimmedString240!): [PpmTask!]!

  # Gets PpmTasks by project.  Returns empty list if none are found
  ppmTaskByProjectId(projectId: String!): [PpmTask!]!

  # Gets PpmTasks by project.  Returns empty list if none are found
  ppmTaskByProjectNumber(projectNumber: PpmProjectNumber!): [PpmTask!]!

  # Gets PpmTasks by projectNumber and taskNumber.  Returns undefined if not found
  ppmTaskByProjectNumberAndTaskNumber(
    projectNumber: PpmProjectNumber!
    taskNumber: PpmTaskNumber!
  ): PpmTask

  # Search for PpmTask objects by multiple properties.
  # See
  # See the PpmTaskFilterInput type for options.
  ppmTaskSearch(filter: PpmTaskFilterInput!): PpmTaskSearchResults!

  # Get a single PpmTerms by id.  Returns undefined if does not exist
  ppmTerms(id: String!): PpmTerms

  # Gets PpmTermss by category name and name.  Returns undefined if none are found
  ppmTermsByName(categoryName: String!, name: String!): PpmTerms

  # Gets PpmTermss by distinct category code.  Returns empty list if none are found
  ppmTermsCategories: [PpmTerms!]!

  # Search for PpmTerms objects by multiple properties.
  # See
  # See the PpmTermsFilterInput type for options.
  ppmTermsSearch(filter: PpmTermsFilterInput!): PpmTermsSearchResults!

  # Validates that the given set of PPM segments are most likely valid for posting
  # to the Oracle ERP PPM Module sub-ledger.  Individual non-blank elements will be checked
  # for current validity.
  #
  # If no date is passed, today's date will be assumed.
  #
  # This operation will return a fully populated set of segments.
  ppmSegmentsValidate(segments: PpmSegmentInput!): PpmSegmentsValidateOutput!

  # Validates that the given PPM chartstring is most likely valid for posting
  # to the Oracle ERP PPM Module sub-ledger.  Individual non-blank elements will be checked
  # for current validity.
  #
  # If no date is passed, today's date will be assumed.
  #
  # This operation will return a fully populated set of segments.
  #
  # This operation will return the validation result and the segments as parsed out into their component fields.
  ppmStringSegmentsValidate(
    segmentString: PpmSegmentString!
  ): PpmSegmentsValidateOutput!

  # Get the status of a previously submitted payable payment request by the API-assigned request ID.
  scmInvoicePaymentRequestStatus(
    requestId: String!
  ): ScmInvoicePaymentRequestStatusOutput

  # Get the status of a previously submitted payable payment request by the consumer's unique tracking ID.
  scmInvoicePaymentRequestStatusByConsumerTracking(
    consumerTrackingId: String!
  ): ScmInvoicePaymentRequestStatusOutput

  # Get the statuses of previously submitted payable payment requests by the consumer's reference ID.
  scmInvoicePaymentRequestStatusByConsumerReference(
    consumerReferenceId: String!
  ): ScmInvoicePaymentRequestStatusOutput

  # Get a single ScmPaymentTerm by unitOfMeasureId.  Returns undefined if does not exist
  scmPaymentTerm(termId: String!): ScmPaymentTerm

  # Get a single ScmPaymentTerm by category code.  Returns undefined if does not exist
  scmPaymentTermByName(name: String!): ScmPaymentTerm

  # Search for ScmPaymentTerm objects by multiple properties.
  # See the ScmPaymentTermFilterInput type for options.
  scmPaymentTermSearch(
    filter: ScmPaymentTermFilterInput!
  ): ScmPaymentTermSearchResults!

  # Get the status of a previously submitted Purchase Requisition request by the API-assigned request ID.
  scmPurchaseRequisitionRequestStatus(
    requestId: String!
  ): ScmPurchaseRequisitionRequestStatusOutput

  # Get the status of a previously submitted purchase requisition request by the consumer's unique tracking ID.
  scmPurchaseRequisitionRequestStatusByConsumerTracking(
    consumerTrackingId: String!
  ): ScmPurchaseRequisitionRequestStatusOutput

  # Get a single ScmPurchasingCategory by unitOfMeasureId.  Returns undefined if does not exist
  scmPurchasingCategory(categoryId: String!): ScmPurchasingCategory

  # Get a single ScmPurchasingCategory by category code.  Returns undefined if does not exist
  scmPurchasingCategoryByPurchasingCategoryCode(
    categoryCode: String!
  ): ScmPurchasingCategory

  # Search for ScmPurchasingCategory objects by multiple properties.
  # See the ScmPurchasingCategoryFilterInput type for options.
  scmPurchasingCategorySearch(
    filter: ScmPurchasingCategoryFilterInput!
  ): ScmPurchasingCategorySearchResults!

  # Get a single ScmSupplier by supplierId.  Returns undefined if does not exist
  scmSupplier(supplierId: String!): ScmSupplier

  # Get a single ScmSupplier by supplier number.  Returns undefined if does not exist
  scmSupplierByNumber(supplierNumber: String!): ScmSupplier

  # Search for ScmSupplier objects by multiple properties.
  # See the ScmSupplierFilterInput type for options.
  scmSupplierSearch(filter: ScmSupplierFilterInput!): ScmSupplierSearchResults!

  # Return the current API Information Object
  erpApiInfo: ErpApiInfo!
}

union _Entity =
    ApAccountingPeriod
  | ArAccountingPeriod
  | ArCustomerAccount
  | ArMemoLine
  | ArPaymentTerm
  | ErpAccount
  | ErpActivity
  | ErpEntity
  | ErpFinancialDepartment
  | ErpFund
  | ErpProgram
  | ErpProject
  | ErpPurpose
  | ErpUnitOfMeasure
  | ErpUser
  | GlAccountingPeriod
  | PpmExpenditureType
  | PpmFundingSource
  | PpmKeywords
  | PpmOrganization
  | PpmProject
  | PpmTask
  | PpmTerms
  | ScmPaymentTerm
  | ScmPurchasingCategory
  | ScmSupplier

scalar _Any

type _Service {
  # The sdl representing the federated service capabilities. Includes federation directives, removes federation types, and includes rest of full schema after schema directives have been applied
  sdl: String
}

type Mutation {
  # Requests that a Accounts Receivable Invoice be uploaded to Oracle.
  arInvoiceCreate(data: ArInvoiceRequestInput!): ArInvoiceRequestStatusOutput!

  # Requests that a Journal Voucher and/or PPM Costing file be uploaded to Oracle.
  #
  # The journal voucher is the primary interface for loading transactions into Oracle from boundary systems.  It is used regardless of whether the expenses are costs which can be applied to the general ledger or must be expensed to the PPM sub-ledger.  The data model in the request allows for all fields which might be needed for GL or PPM transactions to be provided.  However, it is up to the caller to know and fill out the fields properly.  Where possible, the API will reject invalid data prior to it being sent to Oracle.
  #
  # This API replaces the KFS GL Collector process.  While the valid values of the FAU components (now called chartstring segments) have changed, the basic concepts of feeding transactional data to the financial system have not.  As always, transactions submitted to the GL must be balanced between debits and credits.  Valid values must be used for certain fields, and fields have content and length limits.
  #
  # The correct values to use for chartstring segments is out of scope for this documentation.  This API is the mechanism by which you submit values already determined to be functionally correct to the financial system.  Other operations on this server provide data retrieval and validation tools to support generation of correct data payloads for the API.
  #
  # Please see below in this document for examples of payloads into this API.
  #
  # #### Supporting Operations
  #
  # Other operations which should be used to pre-validate chartstring segments are below.  Please see <https://financeandbusiness.ucdavis.edu/aggie-enterprise/chart-of-accounts/redesign> for information about each of these segments.
  #
  # * [`erpEntity`]({{Queries.erpEntity}})
  # * [`erpFund`]({{Queries.erpFund}})
  # * [`erpFinancialDepartment`]({{Queries.erpFinancialDepartment}})
  # * [`erpAccount`]({{Queries.erpAccount}})
  # * [`erpPurpose`]({{Queries.erpPurpose}})
  # * [`erpProject`]({{Queries.erpProject}})
  # * [`erpProgram`]({{Queries.erpProgram}})
  # * [`erpActivity`]({{Queries.erpActivity}})
  #
  # For validating combinations, the following two operations are provided, differing only in their input format.
  #
  # * [`glValidateChartSegments`]({{Queries.glValidateChartSegments}})
  # * [`glValidateChartstring`]({{Queries.glValidateChartstring}})
  #
  # #### Managed Project Cost Entries (PPM/POET)
  #
  # In addition to the standard GL-type of transaction which aligns with the KFS general ledger, Oracle Financials also utilizes a sub-ledger for tracking costs against managed projects.  This loosely matches contracts and grants (award-based) accounts from KFS, but PPM (Project and Portfolio Management) encompasses more than that.
  #
  # For expenses (or income) which are to be recorded against these managed projects, the expense must be recorded in the sub-ledger first, using a different set of chartstring values.  This interface allows you to provide both GL and PPM sub-ledger transactions in the same payload.  (Any attempt to record transactions against a managed project directly (using GL segments) will be rejected.)
  #
  # For PPM, you must use a different set of input strings on the journal line, utilizing the 4 fields below (all required):
  #
  # * `p`roject
  # * `o`rganization (same values as `ErpFinancialDepartment`)
  # * `e`xpenditureType (same values as `ErpAccount`)
  # * `t`ask
  #
  # Tasks are child records to each project.  You can obtain the list of valid tasks for any project by referencing the `PpmProject.tasks` property.
  #
  # There are also the two segments listed below.  For API-based use, the framework will pull the correct award and funding source for any sponsored projects.  For file-based submissions, the default values must be included by querying from the `ppmProject` operation.  You can check whether you need to include these by referencing the `sponsoredProject` property on the `PpmProject`.
  #
  # * award (only for sponsored projects)
  # * fundingSource (only for sponsored projects)
  #
  # As with the GL segments, the API provides the operations below for lookups and validation:
  #
  # * [`ppmProject`]({{Queries.ppmProject}})
  # * [`ppmExpenditureType`]({{Queries.ppmExpenditureType}})
  # * [`ppmOrganization`]({{Queries.ppmOrganization}})
  # * [`ppmSegmentsValidate`]({{Queries.ppmSegmentsValidate}})
  #
  # #### Volume of Data
  #
  # Unlike the use of the KFS ledger, the Oracle Financials general ledger will be a thin ledger.  This means that the level of detail that is allowed to be loaded into the ledger will be limited to summary level information.  It is required that you summarize data down as much as possible to the chartstring segments while being able to retain a link to the source of the transactions.  (E.g., an order number, batch number, or a transaction date)  Submitting lines for each source line item in an external billing system will not be allowed.  Failure to summarize data to an acceptable level will result in loss of API or journal upload access.
  #
  # #### Journal Balancing
  #
  # As with the KFS ledger, journal payloads must balance.  (debit = credits)  Each API payload is a single journal (document number in KFS).
  #
  # While lines with `glSegments` and `ppmSegments` are posted to different ledgers, we can balance across them when creating journals.  Offset entries are required by Oracle to keep the GL in balance until sub-ledger accounting processes execute.  These will be created by the integration framework for you and applied to a central clearing location outside of your department's cost center.
  #
  # #### Basic Use
  #
  # 1. Call the operation (`glJournalRequest`) providing a data payload with the proper structure.  (See [`GlJournalRequestInput`]({{Types.GlJournalRequestInput}}))
  # 2. GraphQL Server will validate content format and reject if invalid.
  # 3. API Server will perform request-specific validation against a local copy of Oracle ERP data.
  # 4. A failure in either of these initial validations will result in an error response with no request being generated.
  # 5. Passing validation will save the request to allow for pickup by the integration platform for processing.
  # 6. A request tracking ID will be generated and returned to allow for the consumer to check on the status of the request and obtain results when completed.
  # 7. At a later time, use the generated request tracking ID against the [`glJournalRequestStatus`]({{Queries.glJournalRequestStatus}}) operation to determine if the request was processed successfully
  glJournalRequest(data: GlJournalRequestInput!): GlJournalRequestStatusOutput!

  # Requests that an Invoice Payment be uploaded to Oracle.
  #
  # This API replaces the various AP Feed flat file upload processes.
  #
  # The correct values to use for chartstring segments is out of scope for this documentation.  This API is the mechanism by which you submit values already determined to be functionally correct to the financial system.  Other operations on this server provide data retrieval and validation tools to support generation of correct data payloads for the API.
  #
  # Please see below in this document for examples of payloads into this API.
  #
  # #### Supporting Operations
  #
  # As this API accepts GL and PPM segments, those must be valid for the request to be accepted.  Please see the [`glJournalCreate`]({{Mutations.glJournalCreate}}) for links to those supporting operations.
  #
  # There are also SCM-specific operations you can use to look up or validate information.
  #
  # * [`scmPaymentTerm`]({{Queries.scmPaymentTerm}})
  # * [`scmPaymentTermSearch`]({{Queries.scmPaymentTermSearch}})
  # * [`erpUnitOfMeasure`]({{Queries.erpUnitOfMeasure}})
  # * [`erpUnitOfMeasureSearch`]({{Queries.erpUnitOfMeasureSearch}})
  # * [`scmSupplierByNumber`]({{Queries.scmSupplierByNumber}})
  # * [`scmSupplierSearch`]({{Queries.scmSupplierSearch}})
  #
  # #### Data Validation
  #
  # ##### GraphQL Data Model and Type Resolvers
  #
  # * Valid JSON data structure.
  # * Required fields (enforced by GraphQL data model)
  # * Ensure required fields are non-blank. (enforced by GraphQL data model)
  # * Ensure fields are formatted properly (enforced by GraphQL data model - and custom code if needed)
  # * Verify maximum lengths on fields.  (Delegate using custom data types if possible.)
  #   * (e.g., `TrimmedNonEmptyString240`)
  #
  # ##### Request Header Checks
  #
  # * Confirm if `consumerTrackingId` previously used and reject if found in the action request table.
  #
  # ##### Data Validation
  #
  # * Validate LineType:  LINE_TYPE_LOOKUP_CODE
  #   * The code you enter must be ITEM, TAX, MISCELLANEOUS, or FREIGHT. Validate against lookup codes stored in the AP_LOOKUP_CODES table
  # * Validate InvoiceType: INVOICE_TYPE_LOOKUP_CODE
  #   * The value must be Credit or Standard. The invoice type must correspond to the invoice amount. For example, Credit invoices must have invoice Amounts less than zero.
  # * Validate unitOfMeasure
  # * Validate paymentTerms: `ScmPaymentTerm`
  # * Check that Supplier is valid. Validate supplierNumber: `ScmSupplier.supplierNumber`
  # * Ensure that the Site is valid. Validate supplierSiteCode: `ScmSupplier.supplierNumber.suppliers.supplierSiteCode`
  # * Check that there is not a previously submitted pending or successful request with the same transaction number for the API consumer.
  # * Verify transaction date within last month?
  # * Verify no line was given both GL and POET segments.
  # * Validate glSegments if present
  # * Validate ppmSegments if present
  # * If provided, verify PO Number is valid
  # * Validate Invoice Number (Verify against `ap_invoices_all`).
  #   * If the Invoice Number already exists in the system for a given Vendor in a given Operating Unit, then another Invoice cannot be created with the same Invoice Number.
  # * Validate Vendor Name.
  #   * The Validation logic should check to see if a vendor already exists for that vendor number. If Yes, then an Invoice can be created for that Supplier. Else, since that Supplier doesn't exist, Invoices cannot be created against that supplier and the validation should result in error.
  # * Validate PO number if one is provided.
  # * Validate Invoice Type (Enum: STANDARD, PREPAYMENT, CREDIT, DEBIT)
  # * Validate Invoice Amount
  #   * Validate Sum of Line Amount equals Invoice Amount
  # * Validate Payment Method Code.
  # * Validate Line Type (Enum: ITEM, FREIGHT, MISCELLANEOUS).
  #
  #
  # #### Basic Use
  #
  # 1. Call the operation (`scmInvoicePaymentCreate`) providing a data payload with the proper structure.  (See [`ScmInvoicePaymentRequestInput`]({{Types.ScmInvoicePaymentRequestInput}}))
  # 2. GraphQL Server will validate content format and reject if invalid.
  # 3. API Server will perform request-specific validation against a local copy of Oracle ERP data.
  # 4. A failure in either of these initial validations will result in an error response with no request being generated.
  # 5. Passing validation will save the request to allow for pickup by the integration platform for processing.
  # 6. A request tracking ID will be generated and returned to allow for the consumer to check on the status of the request and obtain results when completed.
  # 7. At a later time, use the generated request tracking ID against the [`scmInvoicePaymentRequestStatus`]({{Queries.scmInvoicePaymentRequestStatus}}) operation to determine if the request was processed successfully
  scmInvoicePaymentCreate(
    data: ScmInvoicePaymentRequestInput!
  ): ScmInvoicePaymentRequestStatusOutput!

  # Requests that a Purchase Requisition be uploaded to Oracle.
  scmPurchaseRequisitionCreate(
    data: ScmPurchaseRequisitionRequestInput!
  ): ScmPurchaseRequisitionRequestStatusOutput!
}
